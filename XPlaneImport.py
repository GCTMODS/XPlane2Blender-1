#!BPY
""" Registration info for Blender menus:
Name: ' X-Plane Object (.obj)...'
Blender: 240
Group: 'Import'
Tooltip: 'Import an X-Plane scenery or cockpit object (.obj)'
"""
__author__ = "Jonathan Harris"
__url__ = ("Script homepage, http://marginal.org.uk/x-planescenery/")
__version__ = "2.23"
__bpydoc__ = """\
This script imports X-Plane v6, v7 and v8 .obj scenery files into Blender.

Limitations:<br>
  * smoke_black and smoke_white X-Plane primitives are ignored.<br>
  * ambient, difuse, specular, emission and shiny<br>
    attributes are ignored.<br>
  * Can't work out which faces have transparency. You should tell<br>
    Blender which faces are transparent faces by pressing the Alpha<br>
    button in UV Face Select mode after import.<br>
"""

#------------------------------------------------------------------------
# X-Plane importer for blender 2.34 or above
#
# Copyright (c) 2004,2005 Jonathan Harris
# 
# Mail: <x-plane@marginal.org.uk>
# Web:  http://marginal.org.uk/x-planescenery/
#
# See XPlane2Blender.html for usage.
#
# This software is licensed under a Creative Commons License
#   Attribution-ShareAlike 2.0:
#
#   You are free:
#     * to copy, distribute, display, and perform the work
#     * to make derivative works
#     * to make commercial use of the work
#   Under the following conditions:
#     * Attribution: You must give the original author credit.
#     * Share Alike: If you alter, transform, or build upon this work, you
#       may distribute the resulting work only under a license identical to
#       this one.
#   For any reuse or distribution, you must make clear to others the license
#   terms of this work.
#
# This is a human-readable summary of the Legal Code (the full license):
#   http://creativecommons.org/licenses/by-sa/2.0/legalcode
#
#
# 2004-02-01 v1.00
#  - First public version
#
# 2004-02-04 v1.10
#  - Updated for Blender 2.32
#
# 2004-02-05 v1.11
#  - Removed dependency on Python installation
#  - Import at cursor, not origin
#
# 2004-02-08 v1.12
#  - Fixed refusing to recognise DOS-mode v6 files
#  - Fixed triangle texture rotation with v6 files
#
# 2004-02-09 v1.13
#  - Fixed filename bug when texture file is a png
#
# 2004-02-29 v1.20
#  - Emulate Lines with faces
#  - Join adjacent faces into meshes for easier and faster editing
#
# 2004-03-24 v1.30
#  - Reduced duplicate vertex limit from 0.25 to 0.1 to handle smaller objects
#
# 2004-04-10 v1.40
#  - Reduced duplicate vertex limit to 0.01 to handle imported objects
#
# 2004-08-22 v1.50
#  - Reversed meaning of DYNAMIC flag, since it is set by default when
#    creating new faces in Blender
#
# 2004-08-28 v1.60
#  - Added support for double-sided faces
#  - Support importing files with multiple LODs
#
# 2004-08-28 v1.61
#  - Requires Blender 234 due to changed layer semantics of Blender fix #1212
#  - Display number of X-Plane objects on import and export
#
# 2004-08-29 v1.62
#  - Light and Line colours are floats
#
# 2004-08-30 v1.63
#  - Don't set alpha
#
# 2004-09-02 v1.70
#  - Try harder to preserve object names in comments.
#
# 2004-10-10 v1.73
#  - Report line number on input error.
#  - Reduced duplicate vertex limit to 0.001 for small objects eg cockpits.
#
# 2004-10-17 v1.74
#
# 2004-11-01 v1.80
#  - Support for "quad_cockpit" using "Text" button.
#
# 2004-11-14 v1.81
#  - Removed use of "Text" button; cockpit panels now assigned correct texture.
#
# 2004-11-24 v1.83
#  - Use comments to help merge faces into meshes.
#  - Added support for "tri_strip"s (generated by exporting from Plane-Maker).
#  - Try harder to eliminate bogus 2-edged faces in strips.
#
# 2004-12-10 v1.84
#  - Work round duplicate fuselage bug in Plane-Maker 8.0x.
#  - Fixed bug with bogus 2-edged single faces.
#
# 2004-12-29 v1.86
#  - Display WaitCursor during NMesh creation stage.
#
# 2004-12-29 v1.87
#  - Don't set DoubleSided on Meshes since this doesn't do anything useful.
#
# 2004-01-09 v1.89
#  - Detect and fix up spaces in texture file name.
#  - Made merging algorithm thorough.
#
# 2005-01-15 v1.90
#  - Add support for forcing all primitives into a single mesh.
#
# 2005-04-24 v2.00
#  - Default to smooth.
#  - Add support ATTR_reset.
#  - Eliminate ".." from texture paths.
#
# 2005-05-11 v2.03
#  - Fixed bug importing quad_cockpits.
#
# 2005-05-15 v2.05
#  - Fixed bug introduced in 2.04 with twosided polys.
#
# 2005-11-10 v2.10
#  - Add support for v8 objects. No animation yet.
#
# 2005-11-17 v2.11
#  - Import v8 animations at rest position - no armatures yet.
#  - Fixed face flags when no texture.
#  - Added support for v8 alpha and no_alpha pseudo attributes.
#
# 2005-11-19 v2.13
#  - Auto-detect flatness in v8 in the absence of ATTR_no_shade.
#
# 2005-12-19 v2.15
#  - Also look for textures in "textures" subdir.
#
# 2006-01-05 v2.16
#  - Fix for relative and v8 texture paths.
#
# 2006-04-18 v2.20
#  - Now imports successive LODs into different layers, irrespective
#    of LOD range.
#
# 2006-05-07 v2.23
#  - Fix for stupid NPOLY bug introduced in 2.22
#

import sys
import Blender
from Blender import Object, NMesh, Lamp, Image, Material, Window
from XPlaneUtils import Vertex, UV, Face
from os.path import abspath, curdir, dirname, join, normpath, sep, splitdrive
#import time

class ParseError(Exception):
    def __init__(self, type, value=""):
        self.type = type
        self.value = value
    HEADER = 0
    TOKEN  = 1
    INTEGER= 2
    FLOAT  = 3
    MISC   = 4

class Token:
    "OBJ tokens"
    # numbers 1-8 and 99 should not change for v6 compatibility
    LIGHT	= 1
    LINE	= 2
    TRI		= 3
    QUAD	= 4
    QUAD_HARD	= 5
    SMOKE_BLACK	= 6
    SMOKE_WHITE	= 7
    QUAD_MOVIE	= 8
    POLYGON	= 9
    QUAD_STRIP	= 10
    TRI_STRIP	= 11
    TRI_FAN	= 12
    SHADE_FLAT	= 13
    SHADE_SMOOTH= 14
    AMBIENT_RGB	= 15
    DIFUSE_RGB	= 16
    SPECULAR_RGB= 17
    EMISSION_RGB= 18
    SHINY_RAT	= 19
    NO_DEPTH	= 20
    DEPTH	= 21
    LOD		= 22
    RESET	= 23
    NO_CULL	= 24
    NOCULL	= 25
    CULL	= 26
    POLY_OS	= 27
    QUAD_COCKPIT= 28
    TEXTURE	= 29
    TEXTURE_LIT	= 30
    POINT_COUNTS= 31
    SLUNG_LOAD_WEIGHT = 32
    VT		= 33
    VLINE	= 34
    VLIGHT	= 35
    IDX		= 36
    IDX10	= 37
    TRIS	= 38
    LINES	= 39
    LIGHTS	= 40
    HARD	= 41
    NO_HARD	= 42
    COCKPIT	= 43
    NO_COCKPIT	= 44
    BLEND	= 45
    NO_BLEND	= 46
    ANIM_BEGIN	= 47
    ANIM_END	= 48
    ANIM_ROTATE	= 49
    ANIM_TRANS	= 50
    ALPHA	= 51
    NO_ALPHA	= 52
    END		= 99
    NAMES = [
        "",
        "Light",
        "Line",
        "Tri",
        "Quad",
        "Quad_hard",
        "Smoke_Black",
        "Smoke_White",
        "Quad_Movie",
        "Polygon",
        "Quad_Strip",
        "Tri_Strip",
        "Tri_Fan",
        "ATTR_shade_flat",
        "ATTR_shade_smooth",
        "ATTR_ambient_rgb",
        "ATTR_difuse_rgb",
        "ATTR_specular_rgb",
        "ATTR_emission_rgb",
        "ATTR_shiny_rat",
        "ATTR_no_depth",
        "ATTR_depth",
        "ATTR_LOD",
        "ATTR_reset",
        # 7.40+
        "ATTR_no_cull",
        "ATTR_nocull",	# Also seen
        "ATTR_cull",
        "ATTR_poly_os",
        # 8.00+
        "Quad_Cockpit",
        # 8.20+
        "TEXTURE",
        "TEXTURE_LIT",
        "POINT_COUNTS",
        "slung_load_weight",
        "VT",
        "VLINE",
        "VLIGHT",
        "IDX",
        "IDX10",
        "TRIS",
        "LINES",
        "LIGHTS",
        "ATTR_hard",
        "ATTR_no_hard",
        "ATTR_cockpit",
        "ATTR_no_cockpit",
        "ATTR_blend",
        "ATTR_no_blend",
        "ANIM_begin",
        "ANIM_end",
        "ANIM_rotate",
        "ANIM_trans",
        "####_alpha",
        "####_no_alpha",
        ]

class Mesh:
    # Flags
    LAYERMASK=7

    def __init__(self, name, faces=[], layers=1, anim=None):
        self.name=name
        self.layers=layers	# LOD
        self.anim=anim
        self.faces=[]
        self.bmax=Vertex(-sys.maxint,-sys.maxint,-sys.maxint)
        self.bmin=Vertex( sys.maxint, sys.maxint, sys.maxint)
        self.addFaces(name, faces)

    def addFaces(self, name, faces):
        if name != self.name:
            # no longer a standard X-Plane object
            self.name="Mesh"
        self.faces.extend(faces)
        # bounding box
        for face in faces:
            for v in face.v:
                # be inclusive
                if v.x+Vertex.LIMIT > self.bmax.x: self.bmax.x=v.x+Vertex.LIMIT
                if v.y+Vertex.LIMIT > self.bmax.y: self.bmax.y=v.y+Vertex.LIMIT
                if v.z+Vertex.LIMIT > self.bmax.z: self.bmax.z=v.z+Vertex.LIMIT
                if v.x-Vertex.LIMIT < self.bmin.x: self.bmin.x=v.x-Vertex.LIMIT
                if v.y-Vertex.LIMIT < self.bmin.y: self.bmin.y=v.y-Vertex.LIMIT
                if v.z-Vertex.LIMIT < self.bmin.z: self.bmin.z=v.z-Vertex.LIMIT

    #------------------------------------------------------------------------
    # do meshes' bounding boxes intersect?
    def intersect(self,other):
        if (self.bmin.x <= other.bmax.x and
            self.bmin.y <= other.bmax.y and
            self.bmin.z <= other.bmax.z and
            self.bmax.x >= other.bmin.x and
            self.bmax.y >= other.bmin.y and
            self.bmax.z >= other.bmin.z):
            return 1
        return 0
        
    #------------------------------------------------------------------------
    # do faces have any edges in common?
    def abut(self,faces):
        for face1 in self.faces:
            n1=len(face1.v)
            for i1 in range(n1):
                for face2 in faces:
                    n2=len(face2.v)
                    for i2 in range(n2):
                        if ((face1.v[i1].equals(face2.v[i2]) and
                             face1.v[(i1+1)%n1].equals(face2.v[(i2+1)%n2])) or
                            (face1.v[i1].equals(face2.v[(i2+1)%n2]) and
                             face1.v[(i1+1)%n1].equals(face2.v[i2]))):
                            return 1
        return 0

    #------------------------------------------------------------------------
    def doimport(self,scene,image,filename,subroutine):
        
        panel=None
        
        mesh=NMesh.New(self.name)
        mesh.mode &= ~(NMesh.Modes.TWOSIDED|NMesh.Modes.AUTOSMOOTH)
        mesh.mode |= NMesh.Modes.NOVNORMALSFLIP
        mesh.hasFaceUV(1)	# required for face flags

        if self.anim:
            centre=self.anim
        else:
            centre=Vertex(0,0,0)
            if not subroutine:
                n=0
                for f in self.faces:
                    for vertex in f.v:
                        n+=1
                        centre.x+=vertex.x
                        centre.y+=vertex.y
                        centre.z+=vertex.z
                assert n, "Mesh %s has no vertices" % self.name
                centre.x=round(centre.x/n,1)
                centre.y=round(centre.y/n,1)
                centre.z=round(centre.z/n,1)
        
        for f in self.faces:
            face=NMesh.Face()
            face.mode |= NMesh.FaceModes.TEX	# Need this for other flags
            face.mode &= ~(NMesh.FaceModes.TWOSIDE|NMesh.FaceModes.TILES|
                           NMesh.FaceModes.DYNAMIC)
            if not f.flags&Face.HARD:
                face.mode |= NMesh.FaceModes.DYNAMIC
            if f.flags&Face.TWOSIDE:
                face.mode |= NMesh.FaceModes.TWOSIDE
            if not f.flags&Face.NPOLY:
                face.mode |= NMesh.FaceModes.TILES
            if not f.flags&Face.FLAT:
                face.smooth=1
            if f.flags&Face.ALPHA:
                face.transp=NMesh.FaceTranspModes.ALPHA
            else:
                face.transp=NMesh.FaceTranspModes.SOLID
                
            for v in f.v:
                rv=Vertex(v.x-centre.x,v.y-centre.y,v.z-centre.z)
                for nmv in mesh.verts:
                    if rv.equals(Vertex(nmv.co[0],nmv.co[1],nmv.co[2])):
                        nmv.co[0]=(nmv.co[0]+rv.x)/2
                        nmv.co[1]=(nmv.co[1]+rv.y)/2
                        nmv.co[2]=(nmv.co[2]+rv.z)/2
                        face.v.append(nmv)
                        break
                else:
                    nmv=NMesh.Vert(rv.x,rv.y,rv.z)
                    mesh.verts.append(nmv)
                    face.v.append(nmv)

            # Have to add them even if no texture
            for uv in f.uv:
                face.uv.append((uv.s, uv.t))

            if f.flags&Face.PANEL:
                if not panel:
                    d = dirname(filename)
                    for extension in ['.png', '.bmp']:
                        cockpit=d+sep+"cockpit"+sep+"-PANELS-"+sep+"Panel"+extension
                        try:
                            panel = Image.Load(cockpit)
                            break
                        except IOError:
                            pass
                face.image = panel
            elif image:
                face.image = image
                            
            #assert len(face.v)==len(f.v) and len(face.uv)==len(f.uv)
            mesh.faces.append(face)

        ob = Object.New("Mesh", self.name)
        ob.link(mesh)
        scene.link(ob)
        if self.layers&Mesh.LAYERMASK:
            ob.Layer=(self.layers&Mesh.LAYERMASK)
        cur=Window.GetCursorPos()
        ob.setLocation(centre.x+cur[0], centre.y+cur[1], centre.z+cur[2])
        mesh.update(1)
        return ob


#------------------------------------------------------------------------
#-- OBJimport --
#------------------------------------------------------------------------
class OBJimport:
    LAYER=[0,1,2,4]

    #------------------------------------------------------------------------
    def __init__(self, filename, subroutine=False):
        self.subroutine=subroutine
        
        #--- public you can change these ---
        self.verbose=1	# level of verbosity in console: 1-some,2-chat,3-debug
        self.merge=1	# merge primitives into meshes: 0-no,1-abut,2-force
        if subroutine:	# Object is being merged into something else
            self.verbose=0
            self.merge=2
        
        #--- class private don't touch ---
        if filename[0:2] in ['//', '\\\\']:
            # relative to .blend file
            self.filename=normpath(join(dirname(Blender.Get('filename')),
                                        filename[2:]))
        else:
            self.filename=abspath(filename)
        if sep=='\\':
            if self.filename[0] in ['/', '\\']:
                # Add Windows drive letter
                (drive,foo)=splitdrive(Blender.sys.progname)
                self.filename=drive.lower()+self.filename
            else:
                # Lowercase Windows drive lettter
                self.filename=filename[0].lower()+self.filename[1:]

        self.linesemi=0.025
        self.lineno=1		# for error reporting
        self.filelen=0		# for progress reports
        self.fileformat=0	# 6, 7 or 8
        self.image=None		# texture image, iff scenery has texture
        self.curmesh=[]		# unoutputted meshes
        self.nprim=0		# Number of X-Plane objects imported
        self.animerr=False
        
        # random stuff
        self.whitespace=[' ','\t','\n']

        # flags controlling import
        self.comment=""
        self.lastcomment=""
        self.lod=0
        self.fusecount=0

        # v8 structures
        self.vt=[]
        self.vline=[]
        self.vlight=[]
        self.idx=[]
        
        # attributes
        self.hard=False
        self.twoside=False
        self.flat=False		# >=7.30 defaults to smoothed
        self.alpha=False
        self.panel=False
        self.poly=False
        self.anim=[None]		# point of rotation
        self.off=[Vertex(0,0,0)]	# for offsetting

    #------------------------------------------------------------------------
    def doimport(self):
        #clock=time.clock()	# Processor time
        if self.verbose:
            print "Starting OBJ import from " + self.filename
        Blender.Window.WaitCursor(1)
    
        self.file = open(self.filename, 'rU')
        self.file.seek(0,2)
        self.filelen=self.file.tell()
        self.file.seek(0)
        if not self.subroutine: Window.DrawProgressBar(0, "Opening ...")
        self.readHeader()
        ob=self.readObjects()
        if not self.subroutine: Window.DrawProgressBar(1, "Finished")
        if self.verbose:
            print "Finished - imported %s primitives\n" % self.nprim
        #print "%s CPU time\n" % (time.clock()-clock)
        return ob

    #------------------------------------------------------------------------
    def getInput(self):
        # Skip whitespace
        while 1:
            c=self.file.read(1)
            if not c:
            	raise ParseError(ParseError.MISC, 'Unexpected <EOF>')
            elif c in self.whitespace:
                if c=='\n':
                    if self.fileformat<8:
                        self.lineno += 1
                    else:
                        raise ParseError(ParseError.MISC, 'Unexpected newline')
            else:
                break
        input=c
        while 1:
            pos = self.file.tell()
            c = self.file.read(1)
            if not c:
            	raise ParseError(ParseError.MISC, 'Unexpected <EOF>')
            elif c in self.whitespace:
                if c=='\n':
                    if self.fileformat<8:
                        self.lineno += 1
                    else:
                        self.file.seek(pos)	# stay on this line
                if self.verbose>2:
                    print "Input:\t\"%s\"" % input
                return input
            else:
                input=input+c

    #------------------------------------------------------------------------
    def getToken(self):
        # Skip whitespace & v8-style comment lines
        while 1:
            pos = self.file.tell()
            c=self.file.read(1)
            if not c:
                if self.fileformat<8:
                    raise ParseError(ParseError.TOKEN, "<EOF>")
                else:
                    return Token.END
            elif c in self.whitespace:
                if c == '\n':
                    self.lineno += 1
            elif self.fileformat>=8 and c=='#':
                # Hack!
                for a in [Token.NAMES[Token.ALPHA],
                          Token.NAMES[Token.NO_ALPHA]]:
                    self.file.seek(pos)
                    c=self.file.read(len(a))
                    if c==a:
                        self.file.seek(pos)
                        c=''
                        break
                else:
                    # normal comment
                    self.file.seek(pos)
                    self.getCR()
                    continue
                break
            else:
                break
        input=c
        if not self.subroutine:
            Window.DrawProgressBar(float(pos)*0.5/self.filelen,
                                   "Importing %s%% ..." %(pos*50/self.filelen))
        while 1:
            pos=self.file.tell()
            c=self.file.read(1)
            if not c:
                raise ParseError(ParseError.TOKEN, "<EOF>")
            elif c in self.whitespace:
                if c == '\n':
                    if self.fileformat<8:
                        self.lineno += 1
                    else:
                        self.file.seek(pos)	# stay on this line
                break
            input=input+c
            
        if self.verbose>2:
            print "Token:\t\"%s\"" % input

        if self.fileformat>6:
            # names
            u=input.lower()
            for i in range(len(Token.NAMES)):
                if u==Token.NAMES[i].lower():
                    return i
            if self.fileformat==7 and u=='end':
                return Token.END
        else:
            # numbers
            try:
                return int(input)
            except ValueError:
                raise ParseError(ParseError.TOKEN, input)
        raise ParseError(ParseError.TOKEN, input)
        
    #------------------------------------------------------------------------
    def getInt(self):
        c=self.getInput()
        try:
            return int(c)
        except ValueError:
            raise ParseError(ParseError.INTEGER, c)
    
    #------------------------------------------------------------------------
    def getFloat(self):
        c=self.getInput()
        try:
            return float(c)
        except ValueError:
            raise ParseError(ParseError.FLOAT, c)
    
    #------------------------------------------------------------------------
    def getCol(self):
        v=[]
        for i in range(3):
            c=self.getFloat()
            if self.fileformat<8:
                c=c/10.0
            v.append(c)
        return v

    #------------------------------------------------------------------------
    def getVertex(self):
        v=[]
        for i in range(3):
            v.append(self.getFloat())
        # Rotate to Blender format
        return Vertex(round( v[0],Vertex.ROUND),
                      round(-v[2],Vertex.ROUND),
                      round( v[1],Vertex.ROUND))
    
    #------------------------------------------------------------------------
    def getUV(self):
        uv=[]
        for i in range(2):
            uv.append(self.getFloat())
        return UV(uv[0],uv[1])
        
    #------------------------------------------------------------------------
    def getCR(self):
        while 1:
            c = self.file.read(1)
            if c in self.whitespace:
                if c == '\n':
                    self.lineno += 1
                    self.comment=''
                    return
            else:
                break
        input=c
        while 1:
            c = self.file.read(1)
            if c == '\n':
                self.lineno += 1
                pos=self.file.tell()
                break
            input+=c            

        if self.fileformat>=8:
            return

        # Gather comment to help with merge
        while input and input[0]=='/':
            input=input[1:]
        self.comment = input.strip()
        # Export used to attach these prefixes to comments
        for c in ["Mesh: ", "Mesh(alpha): ", "Light: ", "Line: "]:
            if self.comment.find (c) == 0:
                self.comment=self.comment[len(c):]
        # Special handling for aircraft.obj
        if self.comment.find ("verts following are a tristrip for ") == 0:
            if self.comment[35:]=="FUSELAGE    station 0":
                self.fusecount=self.fusecount+1
            self.comment=self.comment[35:47].strip()

    #------------------------------------------------------------------------
    def readHeader(self):
        c=self.file.read(1)
        if self.verbose>2:
            print "Input:\t\"%s\"" % c
        if not c in ['A', 'I']:
            raise ParseError(ParseError.HEADER)
        
        self.getCR()
        c = self.file.read(1)
        if self.verbose>2:
            print "Input:\t\"%s\"" % c
        if c=="2":
            self.getCR()
            self.fileformat=6
            if self.verbose>1:
                print "Info:\tThis is an X-Plane v6 format file"
        elif c=="7" and self.file.read(2)=="00":
            self.getCR()
            if self.file.read(3)!="OBJ":
                raise ParseError(ParseError.HEADER)
            self.getCR()
            self.fileformat=7
            if self.verbose>1:
                print "Info:\tThis is an X-Plane v7 format file"
        elif c=="8" and self.file.read(2)=="00":
            self.getCR()
            if self.file.read(3)!="OBJ":
                raise ParseError(ParseError.HEADER)
            self.getCR()
            self.fileformat=8
            if self.verbose>1:
                print "Info:\tThis is an X-Plane v8 format file"
        else:
            raise ParseError(ParseError.HEADER)

        # read texture
        if self.fileformat>=8:
            t=self.getToken()
            if t!=Token.TEXTURE:
                raise ParseError(ParseError.HEADER)
        else:
            # skip to first non-whitespace
            while 1:
                pos = self.file.tell()
                c = self.file.read(1)
                if not c:
                    raise ParseError(ParseError.HEADER)
                if c == '\n':
                    self.lineno += 1 
                if not c in self.whitespace:
                    self.file.seek(pos)
                    break

        # read to newline or comment - include spaces
        tex=""
        hitspace=False
        while 1:
            pos = self.file.tell()
            c = self.file.read(1)
            if not c:
                raise ParseError(ParseError.HEADER)
            if c in [' ','\t']:
                hitspace=True
            if (c == '\n' or
                (c == '/' and hitspace and self.fileformat<8) or
                (c == '#' and self.fileformat>=8)):
                self.file.seek(pos)
                break
            tex = tex + c
        self.getCR()
        tex = tex.strip()

        if tex.lower() in ['', 'none']:
            self.image=0
            if self.verbose>1:
                print "Info:\tNo texture"
            return

        base=tex.replace(':',sep)

        # Look for texture in . and "../custom object textures"
        dirs=[dirname(self.filename)]
        l=self.filename.rfind('custom objects')
        if l!=-1:
            dirs.append(self.filename[:l]+'custom object textures')
        for subdir in dirs:
            for extension in ['', '.png', '.bmp']:
                texname=normpath(subdir+sep+base+extension)
                try:
                    file = open(texname, "rb")
                except IOError:
                    pass
                else:
                    # Detect and fix up spaces in texture file name
                    if base.find(" ") != -1:
                        newname=normpath(subdir+sep+base.replace(' ','_')+
                                         extension)
                        newfile=open(newname, "wb")
                        newfile.write(file.read())
                        newfile.close()
                        texname=newname
                        print "Info:\tCreated new texture file \"%s\"" % (
                            texname)
                    elif self.verbose>1:
                        print "Info:\tUsing texture file \"%s\"" % texname
                    file.close()
                    self.image = Image.Load(texname)
                    return
            
        self.image=0
        print "Warn:\tTexture file \"%s\" not found" % base
            
    #------------------------------------------------------------------------
    def readObjects (self):
        scene = Blender.Scene.getCurrent();

        if self.fileformat==8:
            while 1:
                t=self.getToken()

                if t==Token.END:
                    # write meshes
                    self.mergeMeshes()
                    for mesh in self.curmesh:
                        last=mesh.doimport(scene,self.image,self.filename,
                                           self.subroutine)
                    return last

                elif t==Token.VLIGHT:
                    v=self.getVertex()
                    c=self.getCol()
                    self.vlight.append((v,c))

                elif t==Token.VLINE:
                    v=self.getVertex()
                    c=self.getCol()
                    self.vline.append((v,c))

                elif t==Token.VT:
                    v=self.getVertex()
                    n=self.getVertex()	# normal
                    uv=self.getUV()
                    self.vt.append((v,uv,n))

                elif t==Token.IDX:
                    self.idx.append(self.getInt())

                elif t==Token.IDX10:
                    for i in range(10):
                        self.idx.append(self.getInt())

                elif t==Token.LIGHTS:
                    a=self.getInt()
                    b=self.getInt()
                    for i in range(a,a+b):
                        (v,c)=self.vlight[i]
                        self.addLamp(scene,v,c)

                elif t==Token.LINES:
                    a=self.getInt()
                    b=self.getInt()
                    for i in range(a,a+b,2):
                        v=[]
                        for j in range(i,i+2):
                            (vj,cj)=self.vline[self.idx[j]]
                            v.append(vj)
                            c=cj	# use second colour value
                        self.addLine(scene,v,c)

                elif t==Token.TRIS:
                    a=self.getInt()
                    b=self.getInt()
                    for i in range(a,a+b,3):
                        v=[]
                        uv=[]
                        n=[]
                        for j in range(i,i+3):
                            (vj,uvj,nj)=self.vt[self.idx[j]]
                            v.append(vj)
                            uv.append(uvj)
                            n.append(nj)
                        # autodetect flatness if ATTR_no_shade not supplied
                        if (not self.flat and
                            n[0].equals(n[1]) and
                            n[1].equals(n[2])):
                            # Should check that vertex normals equal plane
                            # normal, but unlikely that won't be true.
                            self.flat=True
                            self.addFan(scene,t,v,uv)
                            self.flat=False
                        else:
                            self.addFan(scene,t,v,uv)

                elif t==Token.ANIM_BEGIN:
                    if not self.animerr:
                        self.animerr=True
                        print "Warn:\tIgnoring unsupported Animations"
                    self.anim.insert(0, self.anim[0])	# default to last
                    self.off.insert(0, self.off[0])	# cumulative
                    
                elif t==Token.ANIM_END:
                    if not len(self.anim):
                        raise ParseError(ParseError.MISC,
                                         'ANIM_END with no matching ANIM_BEGIN')
                    self.anim.pop(0)
                    self.off.pop(0)
                    
                elif t==Token.ANIM_TRANS:
                    p1=self.getVertex()
                    p2=self.getVertex()
                    v1=self.getFloat()
                    v2=self.getFloat()
                    dataref=self.getInput()
                    if '/' in dataref:
                        dataref=dataref[:dataref.find('/')+1]
                    self.off[0]=self.off[0]+p1

                elif t==Token.ANIM_ROTATE:
                    p=self.getVertex()
                    r1=self.getFloat()
                    r2=self.getFloat()
                    v1=self.getFloat()
                    v2=self.getFloat()
                    dataref=self.getInput()
                    self.anim[0]=self.off[0]

                elif t==Token.HARD:
                    self.hard = True
                elif t==Token.NO_HARD:
                    self.hard = False

                elif t==Token.COCKPIT:
                    self.panel = True
                elif t==Token.NO_COCKPIT:
                    self.panel = False

                elif t==Token.SHADE_FLAT:
                    self.flat = True
                elif t==Token.SHADE_SMOOTH:
                    self.flat = False
                
                elif t==Token.POLY_OS:
                    n = self.getFloat()
                    self.poly = (n!=0)

                elif t==Token.DEPTH:
                    self.poly=False
                elif t==Token.NO_DEPTH:
                    self.poly=True

                elif t==Token.CULL:
                    self.twoside = False
                elif t in [Token.NO_CULL, Token.NOCULL]:
                    self.twoside = True

                elif t==Token.ALPHA:
                    self.alpha = True
                elif t==Token.NO_ALPHA:
                    self.alpha = False

                elif t==Token.LOD:
                    x = self.getFloat()
                    self.getFloat()
                    if not self.lod:
                        print "Info:\tMultiple Levels Of Detail found"
                    self.lod+=1
                    # Reset attributes
                    self.hard=False
                    self.twoside=False
                    self.flat=False
                    self.alpha=False
                    self.panel=False
                    self.poly=False
                
                elif t==Token.RESET:
                    self.hard=False
                    self.twoside=False
                    self.flat=False
                    self.alpha=False
                    self.panel=False
                    self.poly=False

                elif t in [Token.POINT_COUNTS, Token.TEXTURE_LIT]:
                    # Silently ignore
                    self.getCR()

                else:
                    print "Warn:\tIgnoring unsupported \"%s\"" % Token.NAMES[t]
                    if t in [Token.SMOKE_BLACK, Token.SMOKE_WHITE]:
                        n=4
                    elif t in [Token.AMBIENT_RGB, Token.DIFUSE_RGB,
                               Token.SPECULAR_RGB, Token.EMISSION_RGB]:
                        n=3
                    elif t in [Token.SHINY_RAT, Token.SLUNG_LOAD_WEIGHT]:
                        n=1
                    elif t in [Token.BLEND, Token.NO_BLEND]:
                        n=0
                    else:
                        raise ParseError(ParseError.TOKEN, Token.NAMES[t])

                    for i in range(n):
                        self.getFloat()
                
        elif self.fileformat==7:
            while 1:
                t=self.getToken()

                if t==Token.END:
                    # write meshes
                    self.mergeMeshes()
                    for mesh in self.curmesh:
                        last=mesh.doimport(scene,self.image,self.filename,
                                           self.subroutine)
                    return last
                
                elif t==Token.LIGHT:
                    self.getCR()
                    v=self.getVertex()
                    c=self.getCol()
                    self.addLamp(scene,v,c)

                elif t==Token.LINE:
                    self.getCR()
                    v = []
                    for i in range(2):
                        v.append(self.getVertex())
                        c=self.getCol()	# use second colour value
                    self.addLine(scene,v,c)

                elif t==Token.TRI:
                    self.getCR()
                    v = []
                    uv = []
                    for i in range(3):
                        v.append(self.getVertex())
                        uv.append(self.getUV())
                    self.addFan(scene,t,v,uv)

                elif t in [Token.QUAD,
                           Token.QUAD_HARD,
                           Token.QUAD_MOVIE,
                           Token.QUAD_COCKPIT]:
                    self.getCR()
                    if t==Token.QUAD_HARD:
                        self.hard=True
                    elif t==Token.QUAD_COCKPIT:
                        self.panel=True
                    v = []
                    uv = []
                    for i in range(4):
                        v.append(self.getVertex())
                        uv.append(self.getUV())
                    self.addStrip(scene,t,v,uv,[3,2,1,0])
                    self.hard=False
                    self.panel=False
                                         
                elif t==Token.POLYGON:
                    # add centre point, duplicate first point, use Tri_Fan
                    v = []
                    uv = []
                    cv = [0,0,0]
                    cuv = [0,0]
                    n = self.getInt()
                    self.getCR()
                    for i in range(n):
                        v.append(self.getVertex())
                        cv[0]+=v[i].x
                        cv[1]+=v[i].y
                        cv[2]+=v[i].z
                        uv.append(self.getUV())
                        cuv[0]+=uv[i].s
                        cuv[1]+=uv[i].t
                    cv[0]/=n
                    cv[1]/=n
                    cv[2]/=n
                    cuv[0]/=n
                    cuv[1]/=n
                    v.append(v[0])
                    uv.append(uv[0])
                    v.insert(0,Vertex(cv[0],cv[1],cv[2]))
                    uv.insert(0,UV(cuv[0],cuv[1]))
                    self.addFan(scene,t,v,uv)

                elif t==Token.QUAD_STRIP:
                    n = self.getInt()
                    self.getCR()
                    v = []
                    uv = []
                    for i in range(n):
                        v.append(self.getVertex())
                        uv.append(self.getUV())
                    self.addStrip(scene,t,v,uv,[1,0,2,3])
                        
                elif t==Token.TRI_STRIP:
                    v = []
                    uv = []
                    n = self.getInt()
                    self.getCR()
                    for i in range(n):
                        v.append(self.getVertex())
                        uv.append(self.getUV())
                    self.addStrip(scene,t,v,uv,[0,1,2])

                elif t==Token.TRI_FAN:
                    v = []
                    uv = []
                    n = self.getInt()
                    self.getCR()
                    for i in range(n):
                        v.append(self.getVertex())
                        uv.append(self.getUV())
                    self.addFan(scene,t,v,uv)
                    
                elif t==Token.SHADE_FLAT:
                    self.getCR()
                    self.flat = True
                elif t==Token.SHADE_SMOOTH:
                    self.getCR()
                    self.flat = False
                
                elif t==Token.POLY_OS:
                    n = self.getFloat()
                    self.getCR()
                    self.poly = (n!=0)

                elif t==Token.DEPTH:
                    self.getCR()
                    self.poly=False
                elif t==Token.NO_DEPTH:
                    self.getCR()
                    self.poly=True

                elif t==Token.CULL:
                    self.getCR()
                    self.twoside = False
                elif t in [Token.NO_CULL, Token.NOCULL]:
                    self.getCR()
                    self.twoside = True

                elif t==Token.LOD:
                    x = self.getFloat()
                    self.getFloat()
                    self.getCR()
                    if not self.lod:
                        print "Info:\tMultiple Levels Of Detail found"
                    self.lod+=1
                    # Reset attributes
                    self.twoside=False
                    self.flat=False
                    self.poly=False
                
                elif t==Token.RESET:
                    self.getCR()
                    self.twoside=False
                    self.flat=False
                    self.poly=False

                else:
                    print "Warn:\tIgnoring unsupported \"%s\"" % Token.NAMES[t]
                    if t in [Token.SMOKE_BLACK, Token.SMOKE_WHITE]:
                        n=4
                    elif t in [Token.AMBIENT_RGB, Token.DIFUSE_RGB,
                               Token.SPECULAR_RGB, Token.EMISSION_RGB]:
                        n=3
                    elif t in [Token.SHINY_RAT, Token.SLUNG_LOAD_WEIGHT]:
                        n=1
                    elif t in [Token.BLEND, Token.NO_BLEND]:
                        n=0
                    else:
                        raise ParseError(ParseError.TOKEN, Token.NAMES[t])

                    for i in range(n):
                        self.getFloat()
                    self.getCR()

        else:	# v6
            while 1:
                t=self.getToken()

                if t==Token.END:
                    # write meshes
                    self.mergeMeshes()
                    Blender.Window.WaitCursor(1)
                    for mesh in self.curmesh:
                        last=mesh.doimport(scene,self.image,self.filename,
                                           self.subroutine)
                    return last
    
                elif t==Token.LIGHT:
                    c=self.getCol()
                    self.getCR()
                    v=self.getVertex()
                    self.addLamp(scene,v,c)
                
                elif t==Token.LINE:
                    v = []
                    c=self.getCol()
                    self.getCR()
                    for i in range(2):
                        v.append(self.getVertex())
                    self.addLine(scene,v,c)

                elif t==Token.TRI:
                    v = []
                    uv = []
                    for i in range(4):
                        uv.append(self.getFloat())	# s s t t
                    self.getCR()
                    for i in range(3):
                        v.append(self.getVertex())
                    # UV order appears to be arbitrary
                    self.addFan(scene,t,v,[UV(uv[1],uv[3]),
                                            UV(uv[1],uv[2]),
                                            UV(uv[0],uv[2])])
                elif t in [Token.QUAD,
                           Token.QUAD_HARD,
                           Token.QUAD_MOVIE]:
                    if t==Token.QUAD_HARD:
                        self.hard=True
                    v = []
                    uv = []
                    for i in range(4):
                        uv.append(self.getFloat())
                    self.getCR()
                    for i in range(4):
                        v.append(self.getVertex())
                    self.addStrip(scene,t,v,[UV(uv[1],uv[3]),
                                             UV(uv[1],uv[2]),
                                             UV(uv[0],uv[2]),
                                             UV(uv[0],uv[3])],
                                  [3,2,1,0])
                    self.hard=False

                elif t<0:	# Quad strip
                    self.getCR()
                    n = -t	# number of pairs
                    v = []
                    uv = []
                    for i in range(n):
                        v.append(self.getVertex())
                        v.append(self.getVertex())
                        s=self.getUV()		# s s t t
                        t=self.getUV()
                        uv.append(UV(s.s,t.s))
                        uv.append(UV(s.t,t.t))
                    self.addStrip(scene,Token.QUAD_STRIP,v,uv,[1,0,2,3])

                else:
                    print "Warn:\tIgnoring unsupported \"%s\"" % Token.NAMES[t]
                    self.getCR()
                    if t in [Token.SMOKE_BLACK, Token.SMOKE_WHITE]:
                        n=16
                    else:
                        raise ParseError(ParseError.TOKEN, ("%s" % t))
                        
                    for i in range(n):
                        self.getFloat()

    #------------------------------------------------------------------------
    def addLamp(self, scene, v, c):
        if c[0]==1.1 and c[1]==1.1 and c[2]==1.1:
            c[0]=1
            c[1]=c[2]=0
            name="Nav Left"
        elif c[0]==2.2 and c[1]==2.2 and c[2]==2.2:
            c[1]=1
            c[0]=c[2]=0
            name="Nav Right"
        if ((c[0]==9.9 and c[1]==9.9 and c[2]==9.9) or
            (c[0]==3.3 and c[1]==3.3 and c[2]==3.3)):
            c[0]=1
            c[1]=c[2]=0
            name="Pulse"
        elif ((c[0]==9.8 and c[1]==9.8 and c[2]==9.8) or
              (c[0]==4.4 and c[1]==4.4 and c[2]==4.4)):
            c[0]=c[1]=c[2]=1
            name="Strobe"
        elif c[0]==5.5 and c[1]==5.5 and c[2]==5.5:
            c[0]=c[1]=c[2]=1
            name="Landing"
        elif c[0]==9.7 and c[1]==9.7 and c[2]==9.7:
            c[0]=c[1]=1
            c[2]=0
            name="Traffic"
        elif c[0]<0 or c[1]<0 or c[2]<0:
            c[0]=abs(c[0])
            c[1]=abs(c[1])
            c[2]=abs(c[2])
            name="Flash"
        else:
            name="Light"

        if self.verbose>1:
            print "Info:\tImporting Lamp at line %s \"%s\"" % (
                self.lineno, name)
        lamp=Lamp.New("Lamp", name)
        lamp.col=c
        lamp.mode |= Lamp.Modes.Sphere	# stop lamp colouring whole object
        lamp.dist = 4.0
        ob = Object.New("Lamp", name)
        ob.link(lamp)
        scene.link(ob)
        if self.lod:
            ob.Layer=OBJimport.LAYER[self.lod]
        cur=Window.GetCursorPos()
        ob.setLocation(v.x+self.off[0].x+cur[0],
                       v.y+self.off[0].y+cur[1],
                       v.z+self.off[0].z+cur[2])
        self.nprim+=1
        
    #------------------------------------------------------------------------
    def addLine(self,scene,v,c):
        name=self.name("Line")
        if self.verbose>1:
            print "Info:\tImporting Line at line %s \"%s\"" % (
                self.lineno, name)

        if self.anim[0]:
            centre=self.anim[0]
        else:
            centre=Vertex(round((v[0].x+v[1].x)/2,1),
                          round((v[0].y+v[1].y)/2,1),
                          round((v[0].z+v[1].z)/2,1))
        # Orientation
        d=Vertex(abs(v[0].x-v[1].x),abs(v[0].y-v[1].y),abs(v[0].z-v[1].z))
        if d.z>max(d.x,d.y):
            e=Vertex(self.linesemi,-self.linesemi,0)
        elif d.y>max(d.z,d.x):
            e=Vertex(-self.linesemi,0,self.linesemi)
        else:	# d.x>max(d.y,d.z):
            e=Vertex(0,self.linesemi,-self.linesemi)

        # 'Line's shouldn't be merged, so add immediately 
        mesh=NMesh.New(name)
        mesh.mode &= ~(NMesh.Modes.AUTOSMOOTH|NMesh.Modes.NOVNORMALSFLIP)

        face=NMesh.Face()
        face.mode &= ~(NMesh.FaceModes.TEX|NMesh.FaceModes.TILES)
        face.mode |= (NMesh.FaceModes.TWOSIDE|NMesh.FaceModes.DYNAMIC)

        mesh.verts.append(NMesh.Vert(v[0].x+self.off[0].x-centre.x+e.x,
                                     v[0].y+self.off[0].y-centre.y+e.y,
                                     v[0].z+self.off[0].z-centre.z+e.z))
        mesh.verts.append(NMesh.Vert(v[0].x+self.off[0].x-centre.x-e.x,
                                     v[0].y+self.off[0].y-centre.y-e.y,
                                     v[0].z+self.off[0].z-centre.z-e.z))
        mesh.verts.append(NMesh.Vert(v[1].x+self.off[0].x-centre.x-e.x,
                                     v[1].y+self.off[0].y-centre.y-e.y,
                                     v[1].z+self.off[0].z-centre.z-e.z))
        mesh.verts.append(NMesh.Vert(v[1].x+self.off[0].x-centre.x+e.x,
                                     v[1].y+self.off[0].y-centre.y+e.y,
                                     v[1].z+self.off[0].z-centre.z+e.z))
        for nmv in mesh.verts:
            face.v.append(nmv)

        mesh.materials.append(Material.New(name))
        mesh.materials[0].rgbCol=[c[0],c[1],c[2]]
        face.mat=0
        mesh.faces.append(face)

        ob = Object.New("Mesh", name)
        ob.link(mesh)
        scene.link(ob)
        if self.lod:
            ob.Layer=OBJimport.LAYER[self.lod]
        cur=Window.GetCursorPos()
        ob.setLocation(centre.x+cur[0], centre.y+cur[1], centre.z+cur[2])
        mesh.update(1)
        self.nprim+=1

    #------------------------------------------------------------------------
    def addFan(self, scene, token, v, uv):
        # input v: list of co-ords, uv: corresponding list of uv points
        #	v[0] and uv[0] are common to every triangle
        if self.fileformat>=8:
            name="Mesh"
        else:
            name=self.name(Token.NAMES[token])
        if self.verbose>1:
            print "Info:\tImporting %s at line %s \"%s\"" % (
                Token.NAMES[token], self.lineno, name)
        nv=len(v)

        flags=0
        if self.hard:
            flags |= Face.HARD
        if self.twoside:
            flags |= Face.TWOSIDE
        if self.flat:
            flags |= Face.FLAT
        if not self.poly:
            flags |= Face.NPOLY
        if self.panel:
            flags |= Face.PANEL
        if self.alpha:
            flags |= Face.ALPHA

        faces=[]
        for f in range(1,nv-1):
            face=Face()
            face.flags=flags

            face.addVertex(v[0]+self.off[0])
            face.addVertex(v[f+1]+self.off[0])
            face.addVertex(v[f]+self.off[0])
            face.addUV(uv[0])
            face.addUV(uv[f+1])
            face.addUV(uv[f])

            faces.append(face)

        if faces:
            self.addToMesh(scene,name,faces,
                           OBJimport.LAYER[self.lod],self.anim[0])
            self.nprim+=1

    #------------------------------------------------------------------------
    def addStrip(self, scene, token, v, uv, vorder):
        # input v: list of co-ords, uv: corresponding list of uv points
        #	vorder: order of vertices within each face

        # Hack: Work round duplicate fuselage bug in Plane-Maker 8.0x.
        if self.comment=="FUSELAGE" and self.fusecount==2:
            return

        name=self.name(Token.NAMES[token])
        if token==Token.QUAD_HARD:
            name=self.name(Token.NAMES[Token.QUAD])
        elif token==Token.QUAD_MOVIE:
            name=self.name("Movie")
        elif token==Token.QUAD_COCKPIT:
            name=self.name("Panel")
        if self.verbose>1:
            print "Info:\tImporting %s at line %s \"%s\"" % (
                Token.NAMES[token], self.lineno, name)
        nv=len(v)
        assert not nv%2, "Odd %s vertices in \"%s\"" % (nv, name)

        flags=0
        if self.hard:
            flags |= Face.HARD
        if self.twoside:
            flags |= Face.TWOSIDE
        if self.flat:
            flags |= Face.FLAT
        if not self.poly:
            flags |= Face.NPOLY
        if self.panel:
            flags |= Face.PANEL
        if self.alpha:
            flags |= Face.ALPHA

        n=len(vorder)	# 3 or 4 vertices
        faces=[]
        for f in range(2,nv,n-2):
            face=Face()
            face.flags=flags

            if n==3:
                # vorder not used
                if f%2:
                    for i in range(3):
                        face.addVertex(v[f-2+i]+self.off[0])
                        face.addUV(uv[f-2+i])
                else:
                    for i in range(3):
                        face.addVertex(v[f-i]+self.off[0])
                        face.addUV(uv[f-i])
            else:
                for i in range(4):
                    face.addVertex(v[f-2+vorder[i]]+self.off[0])
                    face.addUV(uv[f-2+vorder[i]])

            # Some people use quads as tris to get round limitations in v6
            # in the way that textures are mapped to triangles. This is
            # unnecessary in v7 and screws up when we try to add the same
            # vertex twice. So manually remove extra vertices
            if face.removeDuplicateVertices() < 3:
                continue
            
            faces.append(face)

        if faces:
            self.addToMesh(scene,name,faces,
                           OBJimport.LAYER[self.lod],self.anim[0])
            self.nprim+=1

    #------------------------------------------------------------------------
    # add faces to existing or new mesh
    def addToMesh (self,scene,name,faces,layers,anim):
        # New faces are added to the existing mesh if:
        #  - they share the same comment, or
        #  - any of the new faces has a common edge with any existing face in
        #    the mesh (and existing and new faces have the same flags).
        # We assume that all the new faces have common edges with each other
        # (and so can be safely added to the same mesh) since they all come
        # from the same X-Plane object).

        if (self.curmesh and
            self.curmesh[-1].layers==layers and
            self.curmesh[-1].anim==anim and
            (self.merge>=2 or
             (self.comment and self.comment==self.lastcomment) or
             self.curmesh[-1].abut(faces))):
            self.curmesh[-1].addFaces (name, faces)
        else:
            # No common edge - new mesh required
            self.curmesh.append(Mesh(name, faces, layers, anim))

        self.lastcomment=self.comment

    #------------------------------------------------------------------------
    # last chance - try to merge meshes that abut each other
    def mergeMeshes (self):
        if not self.merge:
            return

        # Brute force and ignorance algorithm is used. But search most recently
        # added meshes first on the assumption of locality.
        m=len(self.curmesh)-2
        while m>=0:
            n=float(m)/len(self.curmesh)
            if not self.subroutine:
                Window.DrawProgressBar(1-n/2,"Merging %s%% ..." % (
                    100-int(50*n)))

            # optimisation: take a copy of m's faces to prevent comparing any
            # newly merged faces multiple times
            facesm=[]
            for face in self.curmesh[m].faces:
                facesm.append(face)

            l=m+1
            while l<len(self.curmesh):
                if (self.curmesh[l].layers==self.curmesh[m].layers and
                    self.curmesh[l].anim==self.curmesh[m].anim and
                    self.curmesh[l].intersect(self.curmesh[m]) and
                    self.curmesh[l].abut(facesm)):
                    self.curmesh[m].addFaces("Mesh", self.curmesh[l].faces)
                    self.curmesh.pop(l)
                else:
                    l=l+1
            m=m-1

    #------------------------------------------------------------------------
    def name (self, fallback):
        if self.comment=='':
            name=fallback
        else:
            name=self.comment	# [:19].strip()
        return name

#------------------------------------------------------------------------
def file_callback (filename):
    obj=OBJimport(filename)
    try:
        obj.doimport()
    except ParseError, e:
        Blender.Window.WaitCursor(0)
        Blender.Window.DrawProgressBar(0, 'ERROR')
        if e.type == ParseError.HEADER:
            msg='This is not a valid X-Plane v6, v7 or v8 OBJ file'
        else:
            if e.type == ParseError.TOKEN:
                msg='Expecting a Token, found "%s" at line %s' % (
                    e.value, obj.lineno)
            elif e.type == ParseError.INTEGER:
                msg='Expecting an integer, found "%s" at line %s' % (
                    e.value, obj.lineno)
            elif e.type == ParseError.FLOAT:
                msg='Expecting a number, found "%s" at line %s\n' % (
                    e.value, obj.lineno)
            else:
                msg='%s at line %s' % (e.value, obj.lineno)
        print "ERROR:\t%s\n" % msg
        Blender.Draw.PupMenu("ERROR: %s" % msg)
        Blender.Draw.PupMenu(msg)
        Blender.Window.DrawProgressBar(1, 'ERROR')
    obj.file.close()
    Blender.Redraw()

#------------------------------------------------------------------------
# main routine
#------------------------------------------------------------------------

Blender.Window.FileSelector(file_callback,"Import OBJ")
