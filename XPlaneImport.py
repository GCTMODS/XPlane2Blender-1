#!BPY
""" Registration info for Blender menus:
Name: 'X-Plane Object (.obj)...'
Blender: 242
Group: 'Import'
Tooltip: 'Import an X-Plane scenery or cockpit object (.obj)'
"""
__author__ = "Jonathan Harris"
__url__ = ("Script homepage, http://marginal.org.uk/x-planescenery/")
__version__ = "2.33"
__bpydoc__ = """\
This script imports X-Plane v6, v7 and v8 .obj scenery files into Blender.

Limitations:<br>
  * smoke_black and smoke_white X-Plane primitives are ignored.<br>
  * ambient, blend and specular attributes are ignored.<br>
  * Can't work out which faces have transparency. You should tell<br>
    Blender which faces are transparent faces by pressing the Alpha<br>
    button in UV Face Select mode after import.<br>
"""

#------------------------------------------------------------------------
# X-Plane importer for blender 2.41 or above
#
# Copyright (c) 2004,2005 Jonathan Harris
# 
# Mail: <x-plane@marginal.org.uk>
# Web:  http://marginal.org.uk/x-planescenery/
#
# See XPlane2Blender.html for usage.
#
# This software is licensed under a Creative Commons License
#   Attribution-ShareAlike 2.0:
#
#   You are free:
#     * to copy, distribute, display, and perform the work
#     * to make derivative works
#     * to make commercial use of the work
#   Under the following conditions:
#     * Attribution: You must give the original author credit.
#     * Share Alike: If you alter, transform, or build upon this work, you
#       may distribute the resulting work only under a license identical to
#       this one.
#   For any reuse or distribution, you must make clear to others the license
#   terms of this work.
#
# This is a human-readable summary of the Legal Code (the full license):
#   http://creativecommons.org/licenses/by-sa/2.0/legalcode
#
#
# 2004-02-01 v1.00
#  - First public version
#
# 2004-02-04 v1.10
#  - Updated for Blender 2.32
#
# 2004-02-05 v1.11
#  - Removed dependency on Python installation
#  - Import at cursor, not origin
#
# 2004-02-08 v1.12
#  - Fixed refusing to recognise DOS-mode v6 files
#  - Fixed triangle texture rotation with v6 files
#
# 2004-02-09 v1.13
#  - Fixed filename bug when texture file is a png
#
# 2004-02-29 v1.20
#  - Emulate Lines with faces
#  - Join adjacent faces into meshes for easier and faster editing
#
# 2004-03-24 v1.30
#  - Reduced duplicate vertex limit from 0.25 to 0.1 to handle smaller objects
#
# 2004-04-10 v1.40
#  - Reduced duplicate vertex limit to 0.01 to handle imported objects
#
# 2004-08-22 v1.50
#  - Reversed meaning of DYNAMIC flag, since it is set by default when
#    creating new faces in Blender
#
# 2004-08-28 v1.60
#  - Added support for double-sided faces
#  - Support importing files with multiple LODs
#
# 2004-08-28 v1.61
#  - Requires Blender 234 due to changed layer semantics of Blender fix #1212
#  - Display number of X-Plane objects on import and export
#
# 2004-08-29 v1.62
#  - Light and Line colours are floats
#
# 2004-08-30 v1.63
#  - Don't set alpha
#
# 2004-09-02 v1.70
#  - Try harder to preserve object names in comments.
#
# 2004-10-10 v1.73
#  - Report line number on input error.
#  - Reduced duplicate vertex limit to 0.001 for small objects eg cockpits.
#
# 2004-10-17 v1.74
#
# 2004-11-01 v1.80
#  - Support for "quad_cockpit" using "Text" button.
#
# 2004-11-14 v1.81
#  - Removed use of "Text" button; cockpit panels now assigned correct texture.
#
# 2004-11-24 v1.83
#  - Use comments to help merge faces into meshes.
#  - Added support for "tri_strip"s (generated by exporting from Plane-Maker).
#  - Try harder to eliminate bogus 2-edged faces in strips.
#
# 2004-12-10 v1.84
#  - Work round duplicate fuselage bug in Plane-Maker 8.0x.
#  - Fixed bug with bogus 2-edged single faces.
#
# 2004-12-29 v1.86
#  - Display WaitCursor during NMesh creation stage.
#
# 2004-12-29 v1.87
#  - Don't set DoubleSided on Meshes since this doesn't do anything useful.
#
# 2004-01-09 v1.89
#  - Detect and fix up spaces in texture file name.
#  - Made merging algorithm thorough.
#
# 2005-01-15 v1.90
#  - Add support for forcing all primitives into a single mesh.
#
# 2005-04-24 v2.00
#  - Default to smooth.
#  - Add support ATTR_reset.
#  - Eliminate ".." from texture paths.
#
# 2005-05-11 v2.03
#  - Fixed bug importing quad_cockpits.
#
# 2005-05-15 v2.05
#  - Fixed bug introduced in 2.04 with twosided polys.
#
# 2005-11-10 v2.10
#  - Add support for v8 objects. No animation yet.
#
# 2005-11-17 v2.11
#  - Import v8 animations at rest position - no armatures yet.
#  - Fixed face flags when no texture.
#  - Added support for v8 alpha and no_alpha pseudo attributes.
#
# 2005-11-19 v2.13
#  - Auto-detect flatness in v8 in the absence of ATTR_no_shade.
#
# 2005-12-19 v2.15
#  - Also look for textures in "textures" subdir.
#
# 2006-01-05 v2.16
#  - Fix for relative and v8 texture paths.
#
# 2006-04-18 v2.20
#  - Now imports successive LODs into different layers, irrespective
#    of LOD range.
#
# 2006-05-07 v2.23
#  - Fix for stupid NPOLY bug introduced in 2.22
#
# 2006-07-19 v2.26
#  - Handle bad textures without crashing.
#  - Support for named lights, layer group, custom LOD ranges.
#  - Imports animation armature and bones
#      - doesn't parent objects to bones - see Blender bug #4726
#      - requires 2.41 because of Blender bug #3712
#
# 2006-07-30 v2.28
#  - Workaround for messed up mesh locations in non-visible layers.
#  - Handle long light names using properties.
#  - Support for ANIM_show/hide.
#  - Support for ANIM_hard <surface>.
#
# 2006-08-17 v2.30
#  - Support for slung_load_weight.
#
# 2006-09-29 v2.31
#  - Goes faster (use new Mesh type) - requires 2.42.
#  - Support for materials.
#  - Imports fewer, larger meshes (for speed).
#

import sys
import Blender
from Blender import Armature, Object, Mesh, NMesh, Lamp, Image, Material, Window
from Blender.Mathutils import Matrix, RotationMatrix, TranslationMatrix, Vector
from XPlaneUtils import Vertex, UV, Face, getDatarefs
from os.path import abspath, basename, curdir, dirname, join, normpath, sep, splitdrive
#import time

datarefs={}

class ParseError(Exception):
    def __init__(self, type, value=""):
        self.type = type
        self.value = value
    HEADER = 0
    TOKEN  = 1
    INTEGER= 2
    FLOAT  = 3
    MISC   = 4

class Token:
    "OBJ tokens"
    # numbers 1-8 and 99 should not change for v6 compatibility
    LIGHT	= 1
    LINE	= 2
    TRI		= 3
    QUAD	= 4
    QUAD_HARD	= 5
    SMOKE_BLACK	= 6
    SMOKE_WHITE	= 7
    QUAD_MOVIE	= 8
    POLYGON	= 9
    QUAD_STRIP	= 10
    TRI_STRIP	= 11
    TRI_FAN	= 12
    SHADE_FLAT	= 13
    SHADE_SMOOTH= 14
    AMBIENT_RGB	= 15
    DIFUSE_RGB	= 16
    DIFFUSE_RGB	= 17
    SPECULAR_RGB= 18
    EMISSION_RGB= 19
    SHINY_RAT	= 20
    NO_DEPTH	= 21
    DEPTH	= 22
    LOD		= 23
    RESET	= 24
    NO_CULL	= 25
    NOCULL	= 26
    CULL	= 27
    POLY_OS	= 28
    QUAD_COCKPIT= 29
    TEXTURE	= 30
    TEXTURE_LIT	= 31
    POINT_COUNTS= 32
    SLUNG_LOAD_WEIGHT = 33
    VT		= 34
    VLINE	= 35
    VLIGHT	= 36
    IDX		= 37
    IDX10	= 38
    TRIS	= 39
    LINES	= 40
    LIGHTS	= 41
    HARD	= 42
    NO_HARD	= 43
    COCKPIT	= 44
    NO_COCKPIT	= 45
    BLEND	= 46
    NO_BLEND	= 47
    ANIM_BEGIN	= 48
    ANIM_END	= 49
    ANIM_ROTATE	= 50
    ANIM_TRANS	= 51
    ALPHA	= 52
    NO_ALPHA	= 53
    LIGHT_NAMED = 54
    LIGHT_CUSTOM= 55
    LAYER_GROUP = 56
    ANIM_SHOW	= 57
    ANIM_HIDE	= 58
    END		= 99
    NAMES = [
        "",
        "Light",
        "Line",
        "Tri",
        "Quad",
        "Quad_hard",
        "Smoke_Black",
        "Smoke_White",
        "Quad_Movie",
        "Polygon",
        "Quad_Strip",
        "Tri_Strip",
        "Tri_Fan",
        "ATTR_shade_flat",
        "ATTR_shade_smooth",
        "ATTR_ambient_rgb",
        "ATTR_difuse_rgb",
        "ATTR_diffuse_rgb",
        "ATTR_specular_rgb",
        "ATTR_emission_rgb",
        "ATTR_shiny_rat",
        "ATTR_no_depth",
        "ATTR_depth",
        "ATTR_LOD",
        "ATTR_reset",
        # 7.40+
        "ATTR_no_cull",
        "ATTR_nocull",	# Also seen
        "ATTR_cull",
        "ATTR_poly_os",
        # 8.00+
        "Quad_Cockpit",
        # 8.20+
        "TEXTURE",
        "TEXTURE_LIT",
        "POINT_COUNTS",
        "slung_load_weight",
        "VT",
        "VLINE",
        "VLIGHT",
        "IDX",
        "IDX10",
        "TRIS",
        "LINES",
        "LIGHTS",
        "ATTR_hard",
        "ATTR_no_hard",
        "ATTR_cockpit",
        "ATTR_no_cockpit",
        "ATTR_blend",
        "ATTR_no_blend",
        "ANIM_begin",
        "ANIM_end",
        "ANIM_rotate",
        "ANIM_trans",
        "####_alpha",
        "####_no_alpha",
        # 8.50+
        "LIGHT_NAMED",
        "LIGHT_CUSTOM",
        "ATTR_layer_group",
        "ANIM_show",
        "ANIM_hide",
        ]

class Mat:
    def __init__(self, d=[1,1,1], e=[0,0,0], s=0):
        self.d=d
        self.e=e
        self.s=s
        self.blenderMat=None

    def equals(self, other):
        return (self.d==other.d and self.e==other.e and self.s==other.s)

    def clone(self):
        return Mat(self.d, self.e, self.s)

    def getBlenderMat(self, force=False):
        if not self.blenderMat and (force or self.d!=[1,1,1] or self.e!=[0,0,0] or self.s):
            self.blenderMat=Material.New()
            self.blenderMat.rgbCol=self.d
            self.blenderMat.mirCol=self.e
            if self.e==[0,0,0]:
                self.blenderMat.emit=0
            else:
                self.blenderMat.emit=1
            self.blenderMat.spec=self.s
        return self.blenderMat
    
class MyMesh:
    # Flags
    LAYERMASK=7

    def __init__(self, name, faces=[], surface=None, layers=1, anim=None, mat=None):
        self.name=name
        self.faces=[]
        self.surface=surface	# Hard surface type or None
        self.layers=layers	# LOD
        self.anim=anim		# (armob,bonename)
        self.mat=mat
        self.bmax=Vertex(-sys.maxint,-sys.maxint,-sys.maxint)
        self.bmin=Vertex( sys.maxint, sys.maxint, sys.maxint)
        self.addFaces(name, faces)

    def addFaces(self, name, faces):
        if name != self.name:
            # no longer a standard X-Plane object
            self.name="Mesh"
        self.faces.extend(faces)
        # bounding box
        for face in faces:
            for v in face.v:
                # be inclusive
                if v.x+Vertex.LIMIT > self.bmax.x: self.bmax.x=v.x+Vertex.LIMIT
                if v.y+Vertex.LIMIT > self.bmax.y: self.bmax.y=v.y+Vertex.LIMIT
                if v.z+Vertex.LIMIT > self.bmax.z: self.bmax.z=v.z+Vertex.LIMIT
                if v.x-Vertex.LIMIT < self.bmin.x: self.bmin.x=v.x-Vertex.LIMIT
                if v.y-Vertex.LIMIT < self.bmin.y: self.bmin.y=v.y-Vertex.LIMIT
                if v.z-Vertex.LIMIT < self.bmin.z: self.bmin.z=v.z-Vertex.LIMIT

    #------------------------------------------------------------------------
    # do meshes' bounding boxes intersect?
    def intersect(self,other):
        if (self.bmin.x <= other.bmax.x and
            self.bmin.y <= other.bmax.y and
            self.bmin.z <= other.bmax.z and
            self.bmax.x >= other.bmin.x and
            self.bmax.y >= other.bmin.y and
            self.bmax.z >= other.bmin.z):
            return 1
        return 0
        
    #------------------------------------------------------------------------
    # do faces have any edges in common?
    def abut(self,faces):
        # print "Abut",self.name, len(self.faces), len(faces),
        for face1 in self.faces:
            n1=len(face1.v)
            for i1 in range(n1):
                for face2 in faces:
                    n2=len(face2.v)
                    for i2 in range(n2):
                        if ((face1.v[i1].equals(face2.v[i2]) and
                             face1.v[(i1+1)%n1].equals(face2.v[(i2+1)%n2])) or
                            (face1.v[i1].equals(face2.v[(i2+1)%n2]) and
                             face1.v[(i1+1)%n1].equals(face2.v[i2]))):
                            # print "yes"
                            return True
        # print "no"
        return False

    #------------------------------------------------------------------------
    def doimport(self,scene,image,objimport,subroutine):
        
        mesh=Mesh.New(self.name)
        mesh.mode &= ~(Mesh.Modes.TWOSIDED|Mesh.Modes.AUTOSMOOTH)
        mesh.mode |= Mesh.Modes.NOVNORMALSFLIP

        mat=self.mat.getBlenderMat()
        if mat: mesh.materials+=[mat]
            
        centre=Vertex(0,0,0)
        if self.anim:
            boneloc=Vertex(self.anim[0].getData().bones[self.anim[2]].head['ARMATURESPACE'])
            centre=boneloc-self.anim[1]
        elif not subroutine:
            n=0
            for f in self.faces:
                for vertex in f.v:
                    n+=1
                    centre.x+=vertex.x
                    centre.y+=vertex.y
                    centre.z+=vertex.z
            assert n, "Mesh %s has no vertices" % self.name
            centre.x=round(centre.x/n,2)
            centre.y=round(centre.y/n,2)
            centre.z=round(centre.z/n,2)
        
        faces=[]
        verts=[]
        for f in self.faces:
            face=[]
            for v in f.v:
                face.append(len(verts))
                verts.append([v.x-centre.x, v.y-centre.y, v.z-centre.z])
            faces.append(face)
        mesh.verts.extend(verts)
        mesh.faces.extend(faces)

        i=0
        for face in mesh.faces:
            f=self.faces[i]
            i+=1

            if f.flags&Face.PANEL:
                if not objimport.panelimage:
                    d=dirname(objimport.filename)
                    for extension in ['.png', '.bmp']:
                        cockpit=d+sep+"cockpit"+sep+"-PANELS-"+sep+"Panel"+extension
                        try:
                            objimport.panelimage = Image.Load(cockpit)
                            objimport.panelimage.getSize()	# force load
                            break
                        except:
                            pass
                    else:
                        objimport.panelimage=Image.New('Panel.png',1024,1024,24)
                face.image = objimport.panelimage
            else:
                face.image = image
                            
            face.uv=[Vector(uv.s, uv.t) for uv in f.uv]
            face.mat=0
            face.mode &= ~(Mesh.FaceModes.TWOSIDE|Mesh.FaceModes.TILES|
                           Mesh.FaceModes.DYNAMIC)
            if not f.flags&Face.HARD:
                face.mode |= Mesh.FaceModes.DYNAMIC
            if f.flags&Face.TWOSIDE:
                face.mode |= Mesh.FaceModes.TWOSIDE
            if not f.flags&Face.NPOLY:
                face.mode |= Mesh.FaceModes.TILES
            if f.flags&Face.FLAT:
                face.smooth=0
            else:
                face.smooth=1
            if f.flags&Face.ALPHA:
                face.transp=Mesh.FaceTranspModes.ALPHA
            else:
                face.transp=Mesh.FaceTranspModes.SOLID
                
            #assert len(face.v)==len(f.v) and len(face.uv)==len(f.uv)
        mesh.update()
        
        ob = Object.New("Mesh", self.name)
        ob.link(mesh)
        scene.link(ob)
        if self.anim:
            #print "%s\t(%s) (%s) (%s)" % (self.anim[2], Vertex(self.anim[0].LocX, self.anim[0].LocY, self.anim[0].LocZ), Vertex(self.anim[0].getData().bones[self.anim[2]].head['ARMATURESPACE']), self.anim[1])
            ob.setLocation(self.anim[0].LocX+boneloc.x,
                           self.anim[0].LocY+boneloc.y,
                           self.anim[0].LocZ+boneloc.z)
            self.anim[0].makeParent([ob])
            #ob.parentbonename=self.anim[2]
        else:
            cur=Window.GetCursorPos()
            ob.setLocation(centre.x+cur[0], centre.y+cur[1], centre.z+cur[2])
        if self.surface:
            ob.addProperty('surface', self.surface)
        if self.layers&MyMesh.LAYERMASK:
            ob.Layer=(self.layers&MyMesh.LAYERMASK)

        mesh.sel=True
        mesh.remDoubles(Vertex.LIMIT)	# must be after linked to object
        mesh.sel=False

        scene.makeCurrent()	# for pose in 2.42 - Blender bug #4696
        return ob


#------------------------------------------------------------------------
#-- OBJimport --
#------------------------------------------------------------------------
class OBJimport:
    LAYER=[0,1,2,4]

    #------------------------------------------------------------------------
    def __init__(self, filename, subroutine=False):
        self.subroutine=subroutine
        
        #--- public you can change these ---
        if subroutine:	# Object is being merged into something else
            self.verbose=0
            self.merge=2
        else:
            self.verbose=1	# level of verbosity in console: 1-some,2-chat,3-debug
            self.merge=2	# merge primitives into meshes: 0-no,1-abut,2-force
        
        #--- class private don't touch ---
        if filename[0:2] in ['//', '\\\\']:
            # relative to .blend file
            self.filename=normpath(join(dirname(Blender.Get('filename')),
                                        filename[2:]))
        else:
            self.filename=abspath(filename)
        if sep=='\\':
            if self.filename[0] in ['/', '\\']:
                # Add Windows drive letter
                (drive,foo)=splitdrive(Blender.sys.progname)
                self.filename=drive.lower()+self.filename
            else:
                # Lowercase Windows drive lettter
                self.filename=filename[0].lower()+self.filename[1:]

        self.linesemi=0.025
        self.lineno=1		# for error reporting
        self.filelen=0		# for progress reports
        self.progress=-1
        self.fileformat=0	# 6, 7 or 8
        self.image=None		# texture image, iff scenery has texture
        self.panelimage=None
        self.curmesh=[]		# unoutputted meshes
        self.nprim=0		# Number of X-Plane objects imported
        
        # random stuff
        self.whitespace=[' ','\t','\n']

        # flags controlling import
        self.comment=""
        self.lastcomment=""
        self.layer=0
        self.lod=None		# list of lod limits
        self.fusecount=0

        # v8 structures
        self.vt=[]
        self.vline=[]
        self.vlight=[]
        self.idx=[]
        
        # attributes
        self.hard=False
        self.twoside=False
        self.flat=False		# >=7.30 defaults to smoothed
        self.alpha=False
        self.panel=False
        self.poly=False
        self.drawgroup=None
        self.slung=0
        self.armob=None		# armature Object
        self.arm=None		# Armature
        self.action=None	# armature Action
        self.pendingbone=None	# current bone
        self.off=[]		# offset from current bone
        self.bones=[]		# Latest children
        self.mat=Mat()
        self.mats=[self.mat]	# Cache of mats to prevent duplicates

    #------------------------------------------------------------------------
    def doimport(self):
        #clock=time.clock()	# Processor time
        if self.verbose:
            print "Starting OBJ import from " + self.filename
        Blender.Window.WaitCursor(1)
    
        self.file = open(self.filename, 'rU')
        self.file.seek(0,2)
        self.filelen=self.file.tell()
        self.file.seek(0)
        if not self.subroutine:
            Window.DrawProgressBar(0, "Opening ...")
            scene=Blender.Scene.getCurrent()
            layers=scene.Layers
            scene.Layers=7	# workaround for 2.42 - Blender bug #4696 ?
        self.readHeader()
        ob=self.readObjects()
        if not self.subroutine:
            Window.DrawProgressBar(1, "Finished")
            scene.Layers=layers
        if self.verbose:
            print "Finished - imported %s primitives\n" % self.nprim
        #print "%s CPU time\n" % (time.clock()-clock)
        return ob

    #------------------------------------------------------------------------
    def getInput(self, optional=False):
        # Skip whitespace
        while 1:
            c=self.file.read(1)
            if not c:
            	raise ParseError(ParseError.MISC, 'Unexpected <EOF>')
            elif c in self.whitespace:
                if c=='\n':
                    if self.fileformat<8:
                        self.lineno += 1
                    elif optional:
                        return None
                    else:
                        raise ParseError(ParseError.MISC, 'Unexpected newline')
            else:
                break
        # Read input
        input=c
        while 1:
            pos = self.file.tell()
            c = self.file.read(1)
            if not c:
            	raise ParseError(ParseError.MISC, 'Unexpected <EOF>')
            elif c in self.whitespace:
                if c=='\n':
                    if self.fileformat<8:
                        self.lineno += 1
                    else:
                        self.file.seek(pos)	# stay on this line
                if self.verbose>2:
                    print "Input:\t\"%s\"" % input
                return input
            else:
                input=input+c

    #------------------------------------------------------------------------
    def getToken(self):
        # Skip whitespace & v8-style comment lines
        while 1:
            pos = self.file.tell()
            c=self.file.read(1)
            if not c:
                if 0: #self.fileformat<8:
                    raise ParseError(ParseError.TOKEN, "<EOF>")
                else:
                    return Token.END
            elif c in self.whitespace:
                if c == '\n':
                    self.lineno += 1
            elif self.fileformat>=8 and c=='#':
                # Hack!
                for a in [Token.NAMES[Token.ALPHA],
                          Token.NAMES[Token.NO_ALPHA]]:
                    self.file.seek(pos)
                    c=self.file.read(len(a))
                    if c==a:
                        self.file.seek(pos)
                        c=''
                        break
                else:
                    # normal comment
                    self.file.seek(pos)
                    self.getCR()
                    continue
                break
            elif self.fileformat>=8 and c=='/':
                if self.file.read(1)=='/':
                    # illegal v7-style comment - propsman likes these
                    self.getCR()
                else:
                    # no idea
                    self.file.seek(pos)
                    break
            else:
                break
        input=c
        if not self.subroutine:
            progress=pos*50/self.filelen
            # only update progress bar if need to
            if self.progress!=progress:
                Window.DrawProgressBar(float(pos)*0.5/self.filelen,
                                       "Importing %s%% ..." % progress)
                self.progress=progress
        while 1:
            pos=self.file.tell()
            c=self.file.read(1)
            if not c:
                raise ParseError(ParseError.TOKEN, "<EOF>")
            elif c in self.whitespace:
                if c == '\n':
                    if self.fileformat<8:
                        self.lineno += 1
                    else:
                        self.file.seek(pos)	# stay on this line
                break
            input=input+c
            
        if self.verbose>2:
            print "Token:\t\"%s\"" % input

        if self.fileformat>6:
            # names
            u=input.lower()
            for i in range(len(Token.NAMES)):
                if u==Token.NAMES[i].lower():
                    return i
            if self.fileformat==7 and u=='end':
                return Token.END
        else:
            # numbers
            try:
                return int(input)
            except ValueError:
                raise ParseError(ParseError.TOKEN, input)
        raise ParseError(ParseError.TOKEN, input)
        
    #------------------------------------------------------------------------
    def getInt(self):
        c=self.getInput()
        try:
            return int(c)
        except ValueError:
            raise ParseError(ParseError.INTEGER, c)
    
    #------------------------------------------------------------------------
    def getFloat(self):
        c=self.getInput()
        try:
            return float(c)
        except ValueError:
            raise ParseError(ParseError.FLOAT, c)
    
    #------------------------------------------------------------------------
    def getCol(self):
        v=[]
        for i in range(3):
            c=self.getFloat()
            if self.fileformat<8:
                c=c/10.0
            v.append(c)
        return v

    #------------------------------------------------------------------------
    def getAttr(self):
        v=[self.getFloat() for i in range(3)]
        return v

    #------------------------------------------------------------------------
    def getVertex(self):
        v=[]
        for i in range(3):
            v.append(self.getFloat())
        # Rotate to Blender format
        return Vertex(round( v[0],Vertex.ROUND),
                      round(-v[2],Vertex.ROUND),
                      round( v[1],Vertex.ROUND))
    
    #------------------------------------------------------------------------
    def getUV(self):
        uv=[]
        for i in range(2):
            uv.append(self.getFloat())
        return UV(uv[0],uv[1])
        
    #------------------------------------------------------------------------
    def getCR(self):
        while 1:
            c = self.file.read(1)
            if c in self.whitespace:
                if c == '\n':
                    self.lineno += 1
                    self.comment=''
                    return
            else:
                break
        input=c
        while 1:
            c = self.file.read(1)
            if c == '\n':
                self.lineno += 1
                pos=self.file.tell()
                break
            input+=c            

        if self.fileformat>=8:
            return

        # Gather comment to help with merge
        while input and input[0]=='/':
            input=input[1:]
        self.comment = input.strip()
        # Export used to attach these prefixes to comments
        for c in ["Mesh: ", "Mesh(alpha): ", "Light: ", "Line: "]:
            if self.comment.find (c) == 0:
                self.comment=self.comment[len(c):]
        # Special handling for aircraft.obj
        if self.comment.find ("verts following are a tristrip for ") == 0:
            if self.comment[35:]=="FUSELAGE    station 0":
                self.fusecount=self.fusecount+1
            self.comment=self.comment[35:47].strip()

    #------------------------------------------------------------------------
    def readHeader(self):
        c=self.file.read(1)
        if self.verbose>2:
            print "Input:\t\"%s\"" % c
        if not c in ['A', 'I']:
            raise ParseError(ParseError.HEADER)
        
        self.getCR()
        c = self.file.read(1)
        if self.verbose>2:
            print "Input:\t\"%s\"" % c
        if c=="2":
            self.getCR()
            self.fileformat=6
            if self.verbose>1:
                print "Info:\tThis is an X-Plane v6 format file"
        elif c=="7" and self.file.read(2)=="00":
            self.getCR()
            if self.file.read(3)!="OBJ":
                raise ParseError(ParseError.HEADER)
            self.getCR()
            self.fileformat=7
            if self.verbose>1:
                print "Info:\tThis is an X-Plane v7 format file"
        elif c=="8" and self.file.read(2)=="00":
            self.getCR()
            if self.file.read(3)!="OBJ":
                raise ParseError(ParseError.HEADER)
            self.getCR()
            self.fileformat=8
            if self.verbose>1:
                print "Info:\tThis is an X-Plane v8 format file"
        else:
            raise ParseError(ParseError.HEADER)

        # read texture
        if self.fileformat>=8:
            t=self.getToken()
            if t!=Token.TEXTURE:
                raise ParseError(ParseError.HEADER)
        else:
            # skip to first non-whitespace
            while 1:
                pos = self.file.tell()
                c = self.file.read(1)
                if not c:
                    raise ParseError(ParseError.HEADER)
                if c == '\n':
                    self.lineno += 1 
                if not c in self.whitespace:
                    self.file.seek(pos)
                    break

        # read to newline or comment - include spaces
        tex=""
        hitspace=False
        while 1:
            pos = self.file.tell()
            c = self.file.read(1)
            if not c:
                raise ParseError(ParseError.HEADER)
            if c in [' ','\t']:
                hitspace=True
            if (c == '\n' or
                (c == '/' and hitspace and self.fileformat<8) or
                (c == '#' and self.fileformat>=8)):
                self.file.seek(pos)
                break
            tex = tex + c
        self.getCR()
        tex = tex.strip()

        if tex.lower() in ['', 'none']:
            self.image=Image.New('none',1024,1024,24)
            if self.verbose>1:
                print "Info:\tNo texture"
            return

        base=tex.replace(':',sep)

        # Look for texture in . and "../custom object textures"
        dirs=[dirname(self.filename)]
        l=self.filename.rfind('custom objects')
        if l!=-1:
            dirs.append(self.filename[:l]+'custom object textures')
        for subdir in dirs:
            for extension in ['', '.png', '.bmp']:
                texname=normpath(subdir+sep+base+extension)
                try:
                    file = open(texname, "rb")
                except IOError:
                    pass
                else:
                    # Detect and fix up spaces in texture file name
                    if base.find(" ") != -1:
                        newname=normpath(subdir+sep+base.replace(' ','_')+
                                         extension)
                        newfile=open(newname, "wb")
                        newfile.write(file.read())
                        newfile.close()
                        texname=newname
                        print "Info:\tCreated new texture file \"%s\"" % (
                            texname)
                    elif self.verbose>1:
                        print "Info:\tUsing texture file \"%s\"" % texname
                    file.close()
                    try:
                        self.image = Image.Load(texname)
                        self.image.getSize()	# force load
                    except:
                        print "Warn:\tTexture file \"%s\" cannot be read" % texname
                        self.image=Image.New(basename(texname),1024,1024,24)
                    return
            
        self.image=Image.New(basename(base),1024,1024,24)
        print "Warn:\tTexture file \"%s\" not found" % base
            
    #------------------------------------------------------------------------
    def readObjects (self):
        scene = Blender.Scene.getCurrent()

        if self.fileformat==8:
            while 1:
                t=self.getToken()

                if t==Token.END:
                    # global attributes
                    if (self.drawgroup or self.lod or self.slung) and not self.subroutine:
                        ob = Object.New("Empty", "Attributes")
                        ob.drawSize=0.1
                        #ob.drawMode=2	# 2=OB_PLAINAXES
                        if self.drawgroup:
                            ob.addProperty("group %s" % self.drawgroup[0],
                                           self.drawgroup[1])
                        if self.slung:
                            ob.addProperty("slung_load_weight", self.slung)
                        if self.lod:
                            for i in range(4):
                                if self.lod[i]!=[0,1000,4000,10000][i]:
                                    ob.addProperty("LOD_%d" % i, self.lod[i])
                        scene.link(ob)
                        cur=Window.GetCursorPos()
                        ob.setLocation(cur[0], cur[1], cur[2])
                    # write meshes
                    self.mergeMeshes()
                    for i in range(len(self.curmesh)):
                        Window.DrawProgressBar(0.9+(i/10.0)/len(self.curmesh),
                                               "Adding %d%% ..." % (
                            90+(i*10.0)/len(self.curmesh)))
                        last=self.curmesh[i].doimport(scene,self.image,self,self.subroutine)
                    scene.update(1)	# update poses
                    return last

                elif t==Token.VLIGHT:
                    v=self.getVertex()
                    c=self.getCol()
                    self.vlight.append((v,c))

                elif t==Token.VLINE:
                    v=self.getVertex()
                    c=self.getCol()
                    self.vline.append((v,c))

                elif t==Token.VT:
                    v=self.getVertex()
                    n=self.getVertex()	# normal
                    uv=self.getUV()
                    self.vt.append((v,uv,n))

                elif t==Token.IDX:
                    self.idx.append(self.getInt())

                elif t==Token.IDX10:
                    for i in range(10):
                        self.idx.append(self.getInt())

                elif t==Token.LIGHTS:
                    self.addpendingbone()
                    a=self.getInt()
                    b=self.getInt()
                    for i in range(a,a+b):
                        (v,c)=self.vlight[i]
                        self.addLamp(scene,v,c)

                elif t==Token.LIGHT_NAMED:
                    self.addpendingbone()
                    name=self.getInput()
                    v=self.getVertex()
                    self.addLamp(scene,v,name)

                elif t==Token.LINES:
                    self.addpendingbone()
                    a=self.getInt()
                    b=self.getInt()
                    for i in range(a,a+b,2):
                        v=[]
                        for j in range(i,i+2):
                            (vj,cj)=self.vline[self.idx[j]]
                            v.append(vj)
                            c=cj	# use second colour value
                        self.addLine(scene,v,c)

                elif t==Token.TRIS:
                    self.addpendingbone()
                    a=self.getInt()
                    b=self.getInt()
                    for i in range(a,a+b,3):
                        v=[]
                        uv=[]
                        n=[]
                        for j in range(i,i+3):
                            (vj,uvj,nj)=self.vt[self.idx[j]]
                            v.append(vj)
                            uv.append(uvj)
                            n.append(nj)
                        # autodetect flatness if ATTR_no_shade not supplied
                        if (not self.flat and
                            n[0].equals(n[1]) and
                            n[1].equals(n[2])):
                            # Should check that vertex normals equal plane
                            # normal, but unlikely that won't be true.
                            self.flat=True
                            self.addFan(scene,t,v,uv)
                            self.flat=False
                        else:
                            self.addFan(scene,t,v,uv)

                elif t==Token.ANIM_BEGIN:
                    if not self.arm:
                        self.off=[Vertex(0,0,0)]
                        self.bones=[None]
                        self.armob = Object.New("Armature")
                        self.arm=Armature.Armature("Armature")
                        self.arm.drawNames=True
                        self.arm.drawType=Armature.STICK
                        self.arm.restPosition=True	# for easier parenting
                        self.armob.link(self.arm)
                        scene.link(self.armob)
                        if self.layer:
                            self.armob.Layer=OBJimport.LAYER[self.layer]
                        cur=Window.GetCursorPos()
                        self.armob.setLocation(cur[0], cur[1], cur[2])
                        self.action = Armature.NLA.NewAction()
                        self.action.setActive(self.armob)
                        self.arm.makeEditable()
                    else:
                        self.addpendingbone()
                        self.off.append(self.off[-1])
                        self.bones.append(None)
                    
                elif t==Token.ANIM_END:
                    if not len(self.off):
                        raise ParseError(ParseError.MISC,
                                         'ANIM_END with no matching ANIM_BEGIN')
                    self.addpendingbone()
                    self.off.pop()
                    self.bones.pop()
                    if not self.off:
                        # Back at top level
                        self.arm.update()
                        self.arm=None
                        self.armob=None
                        self.action=None
                    
                elif t==Token.ANIM_TRANS:
                    p1=self.getVertex()
                    p2=self.getVertex()
                    v1=self.getFloat()
                    v2=self.getFloat()
                    dataref=self.getInput().split('/')
                    self.off[-1]=self.off[-1]+p1
                    if not self.pendingbone:
                        if len(self.bones)==1:
                            # first bone in Armature - move armature location
                            self.armob.setLocation(self.off[-1].x+self.armob.LocX, self.off[-1].y+self.armob.LocY, self.off[-1].z+self.armob.LocZ)
                            self.off[-1]=Vertex(0,0,0)
                        else:
                            # first bone at this level - adjust previous tail
                            #self.arm.bones[self.bones[-2]].tail=self.off[-1].toVector(3)
                            pass
                        if not p1.equals(p2):
                            # not just a shift
                            name=dataref[-1]
                            if '[' in name: name=name[:name.index('[')]
                            if len(dataref)>1 and not name in datarefs:
                                self.armob.addProperty(name, '/'.join(dataref[:-1])+'/')
                            if v1!=0 and dataref[-1]+'_v1' not in self.armob.getAllProperties(): self.armob.addProperty(dataref[-1]+'_v1', v1)
                            if v2!=1 and dataref[-1]+'_v2' not in self.armob.getAllProperties(): self.armob.addProperty(dataref[-1]+'_v2', v2)
                            head=self.off[-1]
                            #tail=self.off[-1]+(p2-p1).normalize()*0.1
                            tail=self.off[-1]+Vertex(0,0.1,0)
                            m1=Matrix().identity().resize4x4()
                            m2=TranslationMatrix((p2-p1).toVector(4))
                            self.pendingbone=(dataref[-1], head, tail, m1, m2)

                elif t==Token.ANIM_ROTATE:
                    p=self.getVertex()
                    r1=self.getFloat()
                    r2=self.getFloat()
                    v1=self.getFloat()
                    v2=self.getFloat()
                    dataref=self.getInput().split('/')
                    while r2>=360 or r2<=-360:
                        # hack!
                        r2/=2
                        v2/=2
                    name=dataref[-1]
                    if '[' in name: name=name[:name.index('[')]
                    if len(dataref)>1 and not name in datarefs:
                        self.armob.addProperty(name,'/'.join(dataref[:-1])+'/')
                    if v1!=0 and dataref[-1]+'_v1' not in self.armob.getAllProperties(): self.armob.addProperty(dataref[-1]+'_v1', v1)
                    if v2!=1 and dataref[-1]+'_v2' not in self.armob.getAllProperties(): self.armob.addProperty(dataref[-1]+'_v2', v2)
                    head=self.off[-1]
                    #tail=self.off[-1]+Vertex(p.y,p.z,p.x)*0.1
                    tail=self.off[-1]+Vertex(0,0.1,0)
                    m1=RotationMatrix(r1,4,'r',p.toVector(3))
                    m2=RotationMatrix(r2,4,'r',p.toVector(3))
                    if self.pendingbone:
                        (name, head, tail, o1, o2)=self.pendingbone
                        if name!=dataref[-1]: #or m2[3]==Vector(0,0,0,1):
                            # Different dataref - new bone!
                            self.addpendingbone()
                        else:
                            m1=m1*o1
                            m2=m2*o2
                    self.pendingbone=(dataref[-1], head, tail, m1, m2)

                elif t in [Token.ANIM_SHOW, Token.ANIM_HIDE]:
                    v1=self.getFloat()
                    v2=self.getFloat()
                    dataref=self.getInput().split('/')
                    name=dataref[-1]
                    if '[' in name: name=name[:name.index('[')]
                    if len(dataref)>1 and not name in datarefs:
                        self.armob.addProperty(name,'/'.join(dataref[:-1])+'/')
                    if t==Token.ANIM_SHOW:
                        self.armob.addProperty(dataref[-1]+'_show_v1', v1)
                        self.armob.addProperty(dataref[-1]+'_show_v2', v2)
                    else:
                        self.armob.addProperty(dataref[-1]+'_hide_v1', v1)
                        self.armob.addProperty(dataref[-1]+'_hide_v2', v2)
                           
                elif t==Token.HARD:
                    surface=self.getInput(True)
                    if surface:
                        self.hard = surface
                    else:
                        self.hard = True
                elif t==Token.NO_HARD:
                    self.hard = False

                elif t==Token.COCKPIT:
                    self.panel = True
                elif t==Token.NO_COCKPIT:
                    self.panel = False

                elif t==Token.SHADE_FLAT:
                    self.flat = True
                elif t==Token.SHADE_SMOOTH:
                    self.flat = False
                
                elif t==Token.POLY_OS:
                    n = self.getFloat()
                    self.poly = (n!=0)

                elif t==Token.DEPTH:
                    self.poly=False
                elif t==Token.NO_DEPTH:
                    self.poly=True

                elif t==Token.CULL:
                    self.twoside = False
                elif t in [Token.NO_CULL, Token.NOCULL]:
                    self.twoside = True

                elif t==Token.ALPHA:
                    self.alpha = True
                elif t==Token.NO_ALPHA:
                    self.alpha = False

                elif t==Token.LAYER_GROUP:
                    self.drawgroup=(self.getInput(), self.getInt())
                    
                elif t==Token.SLUNG_LOAD_WEIGHT:
                    self.slung=self.getFloat()
                    
                elif t==Token.LOD:
                    x=int(self.getFloat())
                    y=int(self.getFloat())
                    if not self.layer:
                        print "Info:\tMultiple Levels Of Detail found"
                    if self.layer==0 and x!=0:
                        self.lod=[x,1000,4000,10000]
                    if self.layer<3:
                        self.layer+=1
                    if y!=[0,1000,4000,10000][self.layer]:
                        if not self.lod: self.lod=[0,1000,4000,10000]
                        self.lod[self.layer]=y
                    # Reset attributes
                    self.hard=False
                    self.twoside=False
                    self.flat=False
                    self.alpha=False
                    self.panel=False
                    self.poly=False
                    self.mat=self.mats[0]
                
                elif t==Token.RESET:
                    self.hard=False
                    self.twoside=False
                    self.flat=False
                    self.alpha=False
                    self.panel=False
                    self.poly=False
                    self.mat=self.mats[0]

                elif t in [Token.DIFUSE_RGB, Token.DIFFUSE_RGB]:
                    self.mat=self.mat.clone()
                    self.mat.d=self.getAttr()
                    for m in self.mats:
                        if self.mat.equals(m):
                            self.mat=m
                    else:
                        self.mats.append(self.mat)

                elif t==Token.EMISSION_RGB:
                    self.mat=self.mat.clone()
                    self.mat.e=self.getAttr()
                    for m in self.mats:
                        if self.mat.equals(m):
                            self.mat=m
                    else:
                        self.mats.append(self.mat)

                elif t==Token.SHINY_RAT:
                    self.mat=self.mat.clone()
                    self.mat.s=self.getFloat()
                    for m in self.mats:
                        if self.mat.equals(m):
                            self.mat=m
                    else:
                        self.mats.append(self.mat)

                elif t in [Token.POINT_COUNTS, Token.TEXTURE_LIT]:
                    # Silently ignore
                    self.getCR()

                else:
                    print "Warn:\tIgnoring unsupported \"%s\"" % Token.NAMES[t]
                    self.getCR()
                
        elif self.fileformat==7:
            while 1:
                t=self.getToken()

                if t==Token.END:
                    # global attributes
                    if (self.drawgroup or self.lod) and not self.subroutine:
                        ob = Object.New("Empty", "Attributes")
                        ob.drawSize=0.1
                        #ob.drawMode=2	# 2=OB_PLAINAXES
                        if self.drawgroup:
                            ob.addProperty("group %s" % self.drawgroup[0],
                                           self.drawgroup[1])
                        if self.lod:
                            for i in range(4):
                                if self.lod[i]!=[0,1000,4000,10000][i]:
                                    ob.addProperty("LOD_%d" % i, self.lod[i])
                        scene.link(ob)
                        cur=Window.GetCursorPos()
                        ob.setLocation(cur[0], cur[1], cur[2])
                    # write meshes
                    self.mergeMeshes()
                    for i in range(len(self.curmesh)):
                        Window.DrawProgressBar(0.9+(i/10.0)/len(self.curmesh),
                                               "Adding %d%% ..." % (
                            90+(i*10.0)/len(self.curmesh)))
                        last=self.curmesh[i].doimport(scene,self.image,self,self.subroutine)
                    return last
                
                elif t==Token.LIGHT:
                    self.getCR()
                    v=self.getVertex()
                    c=self.getCol()
                    self.addLamp(scene,v,c)

                elif t==Token.LINE:
                    self.getCR()
                    v = []
                    for i in range(2):
                        v.append(self.getVertex())
                        c=self.getCol()	# use second colour value
                    self.addLine(scene,v,c)

                elif t==Token.TRI:
                    self.getCR()
                    v = []
                    uv = []
                    for i in range(3):
                        v.append(self.getVertex())
                        uv.append(self.getUV())
                    self.addFan(scene,t,v,uv)

                elif t in [Token.QUAD,
                           Token.QUAD_HARD,
                           Token.QUAD_MOVIE,
                           Token.QUAD_COCKPIT]:
                    self.getCR()
                    if t==Token.QUAD_HARD:
                        self.hard=True
                    elif t==Token.QUAD_COCKPIT:
                        self.panel=True
                    v = []
                    uv = []
                    for i in range(4):
                        v.append(self.getVertex())
                        uv.append(self.getUV())
                    self.addStrip(scene,t,v,uv,[3,2,1,0])
                    self.hard=False
                    self.panel=False
                                         
                elif t==Token.POLYGON:
                    # add centre point, duplicate first point, use Tri_Fan
                    v = []
                    uv = []
                    cv = [0,0,0]
                    cuv = [0,0]
                    n = self.getInt()
                    self.getCR()
                    for i in range(n):
                        v.append(self.getVertex())
                        cv[0]+=v[i].x
                        cv[1]+=v[i].y
                        cv[2]+=v[i].z
                        uv.append(self.getUV())
                        cuv[0]+=uv[i].s
                        cuv[1]+=uv[i].t
                    cv[0]/=n
                    cv[1]/=n
                    cv[2]/=n
                    cuv[0]/=n
                    cuv[1]/=n
                    v.append(v[0])
                    uv.append(uv[0])
                    v.insert(0,Vertex(cv[0],cv[1],cv[2]))
                    uv.insert(0,UV(cuv[0],cuv[1]))
                    self.addFan(scene,t,v,uv)

                elif t==Token.QUAD_STRIP:
                    n = self.getInt()
                    self.getCR()
                    v = []
                    uv = []
                    for i in range(n):
                        v.append(self.getVertex())
                        uv.append(self.getUV())
                    self.addStrip(scene,t,v,uv,[1,0,2,3])
                        
                elif t==Token.TRI_STRIP:
                    v = []
                    uv = []
                    n = self.getInt()
                    self.getCR()
                    for i in range(n):
                        v.append(self.getVertex())
                        uv.append(self.getUV())
                    self.addStrip(scene,t,v,uv,[0,1,2])

                elif t==Token.TRI_FAN:
                    v = []
                    uv = []
                    n = self.getInt()
                    self.getCR()
                    for i in range(n):
                        v.append(self.getVertex())
                        uv.append(self.getUV())
                    self.addFan(scene,t,v,uv)
                    
                elif t==Token.SHADE_FLAT:
                    self.getCR()
                    self.flat = True
                elif t==Token.SHADE_SMOOTH:
                    self.getCR()
                    self.flat = False
                
                elif t==Token.POLY_OS:
                    n = self.getFloat()
                    self.getCR()
                    self.poly = (n!=0)

                elif t==Token.DEPTH:
                    self.getCR()
                    self.poly=False
                elif t==Token.NO_DEPTH:
                    self.getCR()
                    self.poly=True

                elif t==Token.CULL:
                    self.getCR()
                    self.twoside = False
                elif t in [Token.NO_CULL, Token.NOCULL]:
                    self.getCR()
                    self.twoside = True

                elif t==Token.LAYER_GROUP:
                    self.drawgroup=(self.getInput(), self.getInt())
                    self.getCR()
                    
                elif t==Token.LOD:
                    x=int(self.getFloat())
                    y=int(self.getFloat())
                    self.getCR()
                    if not self.layer:
                        print "Info:\tMultiple Levels Of Detail found"
                    if self.layer==0 and x!=0:
                        self.lod=[x,1000,4000,10000]
                    if self.layer<3:
                        self.layer+=1
                    if y!=[0,1000,4000,10000][self.layer]:
                        if not self.lod: self.lod=[0,1000,4000,10000]
                        self.lod[self.layer]=y
                    # Reset attributes
                    self.twoside=False
                    self.flat=False
                    self.poly=False
                    self.mat=self.mats[0]
                
                elif t==Token.RESET:
                    self.getCR()
                    self.twoside=False
                    self.flat=False
                    self.poly=False
                    self.mat=self.mats[0]

                elif t in [Token.DIFUSE_RGB, Token.DIFFUSE_RGB]:
                    self.mat=self.mat.clone()
                    self.mat.d=self.getAttr()
                    for m in self.mats:
                        if self.mat.equals(m):
                            self.mat=m
                    else:
                        self.mats.append(self.mat)

                elif t==Token.EMISSION_RGB:
                    self.mat=self.mat.clone()
                    self.mat.e=self.getAttr()
                    for m in self.mats:
                        if self.mat.equals(m):
                            self.mat=m
                    else:
                        self.mats.append(self.mat)

                elif t==Token.SHINY_RAT:
                    self.mat=self.mat.clone()
                    self.mat.s=self.getFloat()
                    for m in self.mats:
                        if self.mat.equals(m):
                            self.mat=m
                    else:
                        self.mats.append(self.mat)

                else:
                    print "Warn:\tIgnoring unsupported \"%s\"" % Token.NAMES[t]
                    if t in [Token.LIGHT_NAMED, Token.LIGHT_CUSTOM]:
                        n=0	# not really
                    elif t in [Token.SMOKE_BLACK, Token.SMOKE_WHITE]:
                        n=4
                    elif t in [Token.AMBIENT_RGB, Token.SPECULAR_RGB]:
                        n=3
                    elif t in [Token.BLEND, Token.NO_BLEND]:
                        n=0
                    else:
                        raise ParseError(ParseError.TOKEN, Token.NAMES[t])

                    for i in range(n):
                        self.getFloat()
                    self.getCR()

        else:	# v6
            while 1:
                t=self.getToken()

                if t==Token.END:
                    # write meshes
                    self.mergeMeshes()
                    for i in range(len(self.curmesh)):
                        Window.DrawProgressBar(0.9+(i/10.0)/len(self.curmesh),
                                               "Adding %d%% ..." % (
                            90+(i*10.0)/len(self.curmesh)))
                        last=self.curmesh[i].doimport(scene,self.image,self,self.subroutine)
                    return last
    
                elif t==Token.LIGHT:
                    c=self.getCol()
                    self.getCR()
                    v=self.getVertex()
                    self.addLamp(scene,v,c)
                
                elif t==Token.LINE:
                    v = []
                    c=self.getCol()
                    self.getCR()
                    for i in range(2):
                        v.append(self.getVertex())
                    self.addLine(scene,v,c)

                elif t==Token.TRI:
                    v = []
                    uv = []
                    for i in range(4):
                        uv.append(self.getFloat())	# s s t t
                    self.getCR()
                    for i in range(3):
                        v.append(self.getVertex())
                    # UV order appears to be arbitrary
                    self.addFan(scene,t,v,[UV(uv[1],uv[3]),
                                            UV(uv[1],uv[2]),
                                            UV(uv[0],uv[2])])
                elif t in [Token.QUAD,
                           Token.QUAD_HARD,
                           Token.QUAD_MOVIE]:
                    if t==Token.QUAD_HARD:
                        self.hard=True
                    v = []
                    uv = []
                    for i in range(4):
                        uv.append(self.getFloat())
                    self.getCR()
                    for i in range(4):
                        v.append(self.getVertex())
                    self.addStrip(scene,t,v,[UV(uv[1],uv[3]),
                                             UV(uv[1],uv[2]),
                                             UV(uv[0],uv[2]),
                                             UV(uv[0],uv[3])],
                                  [3,2,1,0])
                    self.hard=False

                elif t<0:	# Quad strip
                    self.getCR()
                    n = -t	# number of pairs
                    v = []
                    uv = []
                    for i in range(n):
                        v.append(self.getVertex())
                        v.append(self.getVertex())
                        s=self.getUV()		# s s t t
                        t=self.getUV()
                        uv.append(UV(s.s,t.s))
                        uv.append(UV(s.t,t.t))
                    self.addStrip(scene,Token.QUAD_STRIP,v,uv,[1,0,2,3])

                else:
                    print "Warn:\tIgnoring unsupported \"%s\"" % Token.NAMES[t]
                    self.getCR()
                    if t in [Token.SMOKE_BLACK, Token.SMOKE_WHITE]:
                        n=16
                    else:
                        raise ParseError(ParseError.TOKEN, ("%s" % t))
                        
                    for i in range(n):
                        self.getFloat()

    #------------------------------------------------------------------------
    def addLamp(self, scene, v, c):
        propname=None
        if isinstance(c, str):
            name=c	# named light
            # try to be helpful - some names that we know about
            if name in ['airplane_nav_left', 'airplane_beacon'] or name.endswith('_red'):
                c=[1,0,0]
            elif name in ['airplane_nav_right', 'taxi_center_light', 'taxi_g'] or name.endswith('_green'):
                c=[0,1,0]
            elif name in ['taxi_edge_blue', 'taxi_b'] or name.endswith('_blue'):
                c=[0,0,1]
            elif name in ['airplane_strobe', 'airplane_landing', 'airplane_taxi'] or name.endswith('_white'):
                c=[1,1,1]
            else:	# dunno
                c=[0.75,0.75,0.75]
            if len(name)>17 or 'lamp' in name.lower().split():
                # Blender name limit is 17
                propname=name
                name='Named light'
        elif c[0]==1.1 and c[1]==1.1 and c[2]==1.1:
            name="airplane_nav_left"
            c=[1,0,0]
        elif c[0]==2.2 and c[1]==2.2 and c[2]==2.2:
            name="airplane_nav_right"
            c=[0,1,0]
        elif ((c[0]==9.9 and c[1]==9.9 and c[2]==9.9) or
            (c[0]==3.3 and c[1]==3.3 and c[2]==3.3)):
            name="airplane_beacon"
            c=[1,0,0]
        elif ((c[0]==9.8 and c[1]==9.8 and c[2]==9.8) or
              (c[0]==4.4 and c[1]==4.4 and c[2]==4.4)):
            name="airplane_strobe"
            c=[1,1,1]
        elif c[0]==5.5 and c[1]==5.5 and c[2]==5.5:
            name="airplane_landing"
            c=[1,1,1]
        elif c[0]==9.7 and c[1]==9.7 and c[2]==9.7:
            name="Traffic"
            c=[1,1,0]
        elif c[0]<0 or c[1]<0 or c[2]<0:
            name="Flash"
            c=[abs(c[0]),abs(c[1]),abs(c[2])]
        else:
            name="Lamp"

        if self.verbose>1:
            print "Info:\tImporting Lamp at line %s \"%s\"" % (
                self.lineno, name)
        lamp=Lamp.New("Lamp", name)
        lamp.col=c
        lamp.dist=4.0	# arbitrary - stop lamp colouring whole object
        #amp.mode |= Lamp.Modes.Sphere
        ob = Object.New("Lamp", name)
        if propname: ob.addProperty('name', propname)
        ob.link(lamp)
        scene.link(ob)
        if self.layer:
            ob.Layer=OBJimport.LAYER[self.layer]
        if self.armob:
            boneloc=Vertex(self.arm.bones[self.bones[-1]].head['ARMATURESPACE'])
            loc=Vertex(self.armob.loc)+boneloc-self.off[-1]+v
            ob.setLocation(loc.x, loc.y, loc.z)
            self.armob.makeParent([ob])
            #ob.parentbonename=self.anim[2]
        else:
            cur=Window.GetCursorPos()
            ob.setLocation(v.x+cur[0], v.y+cur[1], v.z+cur[2])
        scene.makeCurrent()	# for pose in 2.42 - Blender bug #4696
        self.nprim+=1
        
    #------------------------------------------------------------------------
    def addLine(self,scene,v,c):
        name=self.name("Line")
        if self.verbose>1:
            print "Info:\tImporting Line at line %s \"%s\"" % (
                self.lineno, name)

        if self.armob:
            boneloc=Vertex(self.arm.bones[self.bones[-1]].head['ARMATURESPACE'])
            centre=boneloc-self.off[-1]
        else:
            centre=Vertex(round((v[0].x+v[1].x)/2,1),
                          round((v[0].y+v[1].y)/2,1),
                          round((v[0].z+v[1].z)/2,1))
        # Orientation
        d=Vertex(abs(v[0].x-v[1].x),abs(v[0].y-v[1].y),abs(v[0].z-v[1].z))
        if d.z>max(d.x,d.y):
            e=Vertex(self.linesemi,-self.linesemi,0)
        elif d.y>max(d.z,d.x):
            e=Vertex(-self.linesemi,0,self.linesemi)
        else:	# d.x>max(d.y,d.z):
            e=Vertex(0,self.linesemi,-self.linesemi)

        # 'Line's shouldn't be merged, so add immediately 
        mesh=NMesh.New(name)
        mesh.mode &= ~(NMesh.Modes.AUTOSMOOTH|NMesh.Modes.NOVNORMALSFLIP)

        face=NMesh.Face()
        face.mat=0
        face.mode &= ~(NMesh.FaceModes.TEX|NMesh.FaceModes.TILES)
        face.mode |= (NMesh.FaceModes.TWOSIDE|NMesh.FaceModes.DYNAMIC)

        mesh.verts.append(NMesh.Vert(v[0].x-centre.x+e.x,
                                     v[0].y-centre.y+e.y,
                                     v[0].z-centre.z+e.z))
        mesh.verts.append(NMesh.Vert(v[0].x-centre.x-e.x,
                                     v[0].y-centre.y-e.y,
                                     v[0].z-centre.z-e.z))
        mesh.verts.append(NMesh.Vert(v[1].x-centre.x-e.x,
                                     v[1].y-centre.y-e.y,
                                     v[1].z-centre.z-e.z))
        mesh.verts.append(NMesh.Vert(v[1].x-centre.x+e.x,
                                     v[1].y-centre.y+e.y,
                                     v[1].z-centre.z+e.z))
        for nmv in mesh.verts:
            face.v.append(nmv)

        mat=Mat(c)
        for m in self.mats:
            if mat.equals(m):
                mat=m
        else:
            self.mats.append(mat)
        mesh.materials.append(mat.getBlenderMat(True))
        mesh.faces.append(face)

        ob = Object.New("Mesh", name)
        ob.link(mesh)
        scene.link(ob)
        if self.layer:
            ob.Layer=OBJimport.LAYER[self.layer]
        if self.armob:
            ob.setLocation(self.armob.LocX+boneloc.x,
                           self.armob.LocY+boneloc.y,
                           self.armob.LocZ+boneloc.z)
            self.armob.makeParent([ob])
            #ob.parentbonename=self.anim[2]
        else:
            cur=Window.GetCursorPos()
            ob.setLocation(centre.x+cur[0], centre.y+cur[1], centre.z+cur[2])
        mesh.update(1)
        scene.makeCurrent()	# for pose in 2.42 - Blender bug #4696
        self.nprim+=1

    #------------------------------------------------------------------------
    def addFan(self, scene, token, v, uv):
        # input v: list of co-ords, uv: corresponding list of uv points
        #	v[0] and uv[0] are common to every triangle
        if self.fileformat>=8:
            name="Mesh"
        else:
            name=self.name(Token.NAMES[token])
        if self.verbose>1:
            print "Info:\tImporting %s at line %s \"%s\"" % (
                Token.NAMES[token], self.lineno, name)
        nv=len(v)

        flags=0
        if self.hard:
            flags |= Face.HARD
        if self.twoside:
            flags |= Face.TWOSIDE
        if self.flat:
            flags |= Face.FLAT
        if not self.poly:
            flags |= Face.NPOLY
        if self.panel:
            flags |= Face.PANEL
        if self.alpha:
            flags |= Face.ALPHA

        if isinstance(self.hard, str):
            surface=self.hard
        else:
            surface=None

        faces=[]
        for f in range(1,nv-1):
            face=Face()
            face.flags=flags

            face.addVertex(v[0])
            face.addVertex(v[f+1])
            face.addVertex(v[f])
            face.addUV(uv[0])
            face.addUV(uv[f+1])
            face.addUV(uv[f])

            faces.append(face)

        if faces:
            if self.armob:
                self.addToMesh(scene,name,faces,surface,
                               OBJimport.LAYER[self.layer],
                               (self.armob,self.off[-1],self.bones[-1]),
                               self.mat)
            else:
                self.addToMesh(scene,name,faces,surface,
                               OBJimport.LAYER[self.layer],
                               None, self.mat)
            self.nprim+=1

    #------------------------------------------------------------------------
    def addStrip(self, scene, token, v, uv, vorder):
        # input v: list of co-ords, uv: corresponding list of uv points
        #	vorder: order of vertices within each face

        # Hack: Work round duplicate fuselage bug in Plane-Maker 8.0x.
        if self.comment=="FUSELAGE" and self.fusecount==2:
            return

        name=self.name(Token.NAMES[token])
        if token==Token.QUAD_HARD:
            name=self.name(Token.NAMES[Token.QUAD])
        elif token==Token.QUAD_MOVIE:
            name=self.name("Movie")
        elif token==Token.QUAD_COCKPIT:
            name=self.name("Panel")
        if self.verbose>1:
            print "Info:\tImporting %s at line %s \"%s\"" % (
                Token.NAMES[token], self.lineno, name)
        nv=len(v)
        assert not nv%2, "Odd %s vertices in \"%s\"" % (nv, name)

        flags=0
        if self.hard:
            flags |= Face.HARD
        if self.twoside:
            flags |= Face.TWOSIDE
        if self.flat:
            flags |= Face.FLAT
        if not self.poly:
            flags |= Face.NPOLY
        if self.panel:
            flags |= Face.PANEL
        if self.alpha:
            flags |= Face.ALPHA

        if isinstance(self.hard, str):
            surface=self.hard
        else:
            surface=None

        n=len(vorder)	# 3 or 4 vertices
        faces=[]
        for f in range(2,nv,n-2):
            face=Face()
            face.flags=flags

            if n==3:
                # vorder not used
                if f%2:
                    for i in range(3):
                        face.addVertex(v[f-2+i])
                        face.addUV(uv[f-2+i])
                else:
                    for i in range(3):
                        face.addVertex(v[f-i])
                        face.addUV(uv[f-i])
            else:
                for i in range(4):
                    face.addVertex(v[f-2+vorder[i]])
                    face.addUV(uv[f-2+vorder[i]])

            # Some people use quads as tris to get round limitations in v6
            # in the way that textures are mapped to triangles. This is
            # unnecessary in v7 and screws up when we try to add the same
            # vertex twice. So manually remove extra vertices
            if face.removeDuplicateVertices() < 3:
                continue
            
            faces.append(face)

        if faces:
            if self.armob:
                self.addToMesh(scene,name,faces,surface,
                               OBJimport.LAYER[self.layer],
                               (self.armob,self.off[-1],self.bones[-1]),
                               self.mat)
            else:
                self.addToMesh(scene,name,faces,surface,
                               OBJimport.LAYER[self.layer],
                               None, self.mat)
            self.nprim+=1

    #------------------------------------------------------------------------
    # add faces to existing or new mesh
    def addToMesh (self,scene,name,faces,surface,layers,anim,mat):
        # New faces are added to the existing mesh if:
        #  - they share the same comment, or
        #  - any of the new faces has a common edge with any existing face in
        #    the mesh (and existing and new faces have the same flags).
        # We assume that all the new faces have common edges with each other
        # (and so can be safely added to the same mesh) since they all come
        # from the same X-Plane object).

        if (self.curmesh and
            self.curmesh[-1].layers==layers and
            (self.curmesh[-1].surface==surface or
             not (self.curmesh[-1].surface and surface)) and
            self.curmesh[-1].anim==anim and
            self.curmesh[-1].mat==mat and
            (self.merge>=2 or anim or
             (self.comment and self.comment==self.lastcomment) or
             self.curmesh[-1].abut(faces))):
            self.curmesh[-1].addFaces(name, faces)
            if surface: self.curmesh[-1].surface=surface
        else:
            # No common edge - new mesh required
            self.curmesh.append(MyMesh(name, faces, surface, layers, anim, mat))

        self.lastcomment=self.comment

    #------------------------------------------------------------------------
    # last chance - try to merge meshes that abut each other
    def mergeMeshes (self):
        if not self.merge:
            return

        # Brute force and ignorance algorithm is used. But search most recently
        # added meshes first on the assumption of locality.
        m=len(self.curmesh)-2
        while m>=0:
            n=(m+1.0)/len(self.curmesh)
            if not self.subroutine:
                Window.DrawProgressBar(0.9-0.4*n,"Merging %s%% ..." % (
                    90-int(40*n)))

            # optimisation: take a copy of m's faces to prevent comparing any
            # newly merged faces multiple times
            facesm=[]
            for face in self.curmesh[m].faces:
                facesm.append(face)

            l=m+1
            while l<len(self.curmesh):
                if self.verbose>2: print "Merge", l, m, len(self.curmesh), self.curmesh[l].name, self.curmesh[m].name
                if (self.curmesh[l].layers==self.curmesh[m].layers and
                    (self.curmesh[l].surface==self.curmesh[m].surface or
                     not (self.curmesh[l].surface and self.curmesh[m].surface)) and
                    self.curmesh[l].anim==self.curmesh[m].anim and
                    self.curmesh[l].mat==self.curmesh[m].mat and
                    (self.merge>=2 or
                     (self.curmesh[l].intersect(self.curmesh[m]) and
                      self.curmesh[l].abut(facesm)))):
                    self.curmesh[m].addFaces("Mesh", self.curmesh[l].faces)
                    if self.curmesh[l].surface:
                        self.curmesh[m].surface=self.curmesh[l].surface
                    self.curmesh.pop(l)
                else:
                    l=l+1
            m=m-1

    #------------------------------------------------------------------------
    def addpendingbone(self):
        if not self.pendingbone:
            if self.bones==[None]:
                # eek no bones! Maybe just receptacle for show/hide?
                (origname, head, tail)=('bone', Vertex(0,0,0), Vertex(0,0.1,0))
                m1=m2=Matrix().identity().resize4x4()
            else:
                return None
        else:
            (origname, head, tail, m1, m2)=self.pendingbone
        name=origname
        i=0
        while name in self.arm.bones.keys():
            i+=1
            name="%s.%03d" % (origname, i)
        bone=Armature.Editbone()
        bone.name=name
        i=len(self.bones)-2
        while i>=0:
            if self.bones[-2]:
                bone.parent=self.arm.bones[self.bones[-2]]
                break
            i-=1	# bone will be None if just a shift - use grandparent
        bone.head=head.toVector(3)
        bone.tail=tail.toVector(3)
        self.arm.bones[name]=bone
        self.arm.update()	# to get Pose
        pose=self.armob.getPose()
        posebone=pose.bones[name]
        posebone.localMatrix=m1
        posebone.insertKey(self.armob, 1, [Object.Pose.ROT,Object.Pose.LOC])
        pose.update()
        posebone.localMatrix=m2
        posebone.insertKey(self.armob, 2, [Object.Pose.ROT,Object.Pose.LOC])
        pose.update()
        self.arm.makeEditable()
        self.pendingbone=None
        self.bones[-1]=name

    #------------------------------------------------------------------------
    def name (self, fallback):
        if self.comment=='':
            name=fallback
        else:
            name=self.comment	# [:19].strip()
        return name

#------------------------------------------------------------------------
def file_callback (filename):
    obj=OBJimport(filename)
    try:
        obj.doimport()
    except ParseError, e:
        Blender.Window.WaitCursor(0)
        Blender.Window.DrawProgressBar(0, 'ERROR')
        if e.type == ParseError.HEADER:
            msg='This is not a valid X-Plane v6, v7 or v8 OBJ file'
        else:
            if e.type == ParseError.TOKEN:
                msg='Expecting a Token, found "%s" at line %s' % (
                    e.value, obj.lineno)
            elif e.type == ParseError.INTEGER:
                msg='Expecting an integer, found "%s" at line %s' % (
                    e.value, obj.lineno)
            elif e.type == ParseError.FLOAT:
                msg='Expecting a number, found "%s" at line %s\n' % (
                    e.value, obj.lineno)
            else:
                msg='%s at line %s' % (e.value, obj.lineno)
        print "ERROR:\t%s\n" % msg
        Blender.Draw.PupMenu("ERROR: %s" % msg)
        Blender.Window.DrawProgressBar(1, 'ERROR')
    obj.file.close()
    Blender.Redraw()

#------------------------------------------------------------------------
# main routine
#------------------------------------------------------------------------
try:
    datarefs=getDatarefs()
except IOError, e:
    Window.DrawProgressBar(0, 'ERROR')
    print "ERROR:\t%s\n" % e.strerror
    Blender.Draw.PupMenu("ERROR: %s" % e.strerror)
    Window.DrawProgressBar(1, 'ERROR')
else:
    Window.FileSelector(file_callback,"Import OBJ")
